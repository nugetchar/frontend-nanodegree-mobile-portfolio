<!DOCTYPE html>

<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>index.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>filter will reemit the data if cb(err,pass) pass is truthy</p>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>reduce is more tricky
maybe we want to group the reductions or emit progress updates occasionally
the most basic reduce just emits one ‘data’ event after it has recieved ‘end’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> Stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Stream
  , es = exports
  , through = <span class="hljs-built_in">require</span>(<span class="hljs-string">'through'</span>)
  , from = <span class="hljs-built_in">require</span>(<span class="hljs-string">'from'</span>)
  , duplex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'duplexer'</span>)
  , map = <span class="hljs-built_in">require</span>(<span class="hljs-string">'map-stream'</span>)
  , pause = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pause-stream'</span>)
  , split = <span class="hljs-built_in">require</span>(<span class="hljs-string">'split'</span>)
  , pipeline = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream-combiner'</span>)
  , immediately = global.setImmediate || process.nextTick;

es.Stream = Stream <span class="hljs-comment">//re-export Stream from core</span>
es.through = through
es.from = from
es.duplex = duplex
es.map = map
es.pause = pause
es.split = split
es.pipeline = es.connect = es.pipe = pipeline</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>merge / concat</p>
<p>combine multiple streams into a single stream.
will emit end only once</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.concat = <span class="hljs-comment">//actually this should be called concat</span>
es.merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-comment">/*streams...*/</span></span>) </span>{
  <span class="hljs-keyword">var</span> toMerge = [].slice.call(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (toMerge.length === <span class="hljs-number">1</span> &amp;&amp; (toMerge[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) {
    toMerge = toMerge[<span class="hljs-number">0</span>] <span class="hljs-comment">//handle array as arguments object</span>
  }
  <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> Stream()
  stream.setMaxListeners(<span class="hljs-number">0</span>) <span class="hljs-comment">// allow adding more than 11 streams</span>
  <span class="hljs-keyword">var</span> endCount = <span class="hljs-number">0</span>
  stream.writable = stream.readable = <span class="hljs-literal">true</span>

  toMerge.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
    e.pipe(stream, {end: <span class="hljs-literal">false</span>})
    <span class="hljs-keyword">var</span> ended = <span class="hljs-literal">false</span>
    e.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span>(ended) <span class="hljs-keyword">return</span>
      ended = <span class="hljs-literal">true</span>
      endCount ++
      <span class="hljs-keyword">if</span>(endCount == toMerge.length)
        stream.emit(<span class="hljs-string">'end'</span>) 
    })
  })
  stream.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, data)
  }
  stream.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    toMerge.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">if</span>(e.destroy) e.destroy()
    })
  }
  <span class="hljs-keyword">return</span> stream
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>writable stream, collects all events into an array 
and calls back when ‘end’ occurs
mainly I’m using this to test the other functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.writeArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">done</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-string">'function'</span> !== <span class="hljs-keyword">typeof</span> done)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'function writeArray (done): done must be function'</span>)

  <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Stream ()
    , array = [], isDone = <span class="hljs-literal">false</span>
  a.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{
    array.push(l)
  }
  a.end = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    isDone = <span class="hljs-literal">true</span>
    done(<span class="hljs-literal">null</span>, array)
  }
  a.writable = <span class="hljs-literal">true</span>
  a.readable = <span class="hljs-literal">false</span>
  a.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    a.writable = a.readable = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span>(isDone) <span class="hljs-keyword">return</span>
    done(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'destroyed before end'</span>), array)
  }
  <span class="hljs-keyword">return</span> a
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>return a Stream that reads the properties of an object
respecting pause() and resume()</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.readArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> Stream()
    , i = <span class="hljs-number">0</span>
    , paused = <span class="hljs-literal">false</span>
    , ended = <span class="hljs-literal">false</span>
 
  stream.readable = <span class="hljs-literal">true</span>  
  stream.writable = <span class="hljs-literal">false</span>
 
  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Array</span>.isArray(array))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'event-stream.read expects an array'</span>)
  
  stream.resume = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(ended) <span class="hljs-keyword">return</span>
    paused = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> l = array.length
    <span class="hljs-keyword">while</span>(i &lt; l &amp;&amp; !paused &amp;&amp; !ended) {
      stream.emit(<span class="hljs-string">'data'</span>, array[i++])
    }
    <span class="hljs-keyword">if</span>(i == l &amp;&amp; !ended)
      ended = <span class="hljs-literal">true</span>, stream.readable = <span class="hljs-literal">false</span>, stream.emit(<span class="hljs-string">'end'</span>)
  }
  process.nextTick(stream.resume)
  stream.pause = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
     paused = <span class="hljs-literal">true</span>
  }
  stream.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    ended = <span class="hljs-literal">true</span>
    stream.emit(<span class="hljs-string">'close'</span>)
  }
  <span class="hljs-keyword">return</span> stream
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>readable (asyncFunction)
return a stream that calls an async function while the stream is not paused.</p>
<p>the function must take: (count, callback) {…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.readable =
<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, continueOnError</span>) </span>{
  <span class="hljs-keyword">var</span> stream = <span class="hljs-keyword">new</span> Stream()
    , i = <span class="hljs-number">0</span>
    , paused = <span class="hljs-literal">false</span>
    , ended = <span class="hljs-literal">false</span>
    , reading = <span class="hljs-literal">false</span>

  stream.readable = <span class="hljs-literal">true</span>  
  stream.writable = <span class="hljs-literal">false</span>
 
  <span class="hljs-keyword">if</span>(<span class="hljs-string">'function'</span> !== <span class="hljs-keyword">typeof</span> func)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'event-stream.readable expects async function'</span>)
  
  stream.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ ended = <span class="hljs-literal">true</span> })
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params">err, data</span>) </span>{
    
    <span class="hljs-keyword">if</span>(err) {
      stream.emit(<span class="hljs-string">'error'</span>, err)
      <span class="hljs-keyword">if</span>(!continueOnError) stream.emit(<span class="hljs-string">'end'</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>)
      stream.emit(<span class="hljs-string">'data'</span>, data)

    immediately(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span>(ended || paused || reading) <span class="hljs-keyword">return</span>
      <span class="hljs-keyword">try</span> {
        reading = <span class="hljs-literal">true</span>
        func.call(stream, i++, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          reading = <span class="hljs-literal">false</span>
          get.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>)
        })
      } <span class="hljs-keyword">catch</span> (err) {
        stream.emit(<span class="hljs-string">'error'</span>, err)    
      }
    })
  }
  stream.resume = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    paused = <span class="hljs-literal">false</span>
    get()
  }
  process.nextTick(get)
  stream.pause = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
     paused = <span class="hljs-literal">true</span>
  }
  stream.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    stream.emit(<span class="hljs-string">'end'</span>)
    stream.emit(<span class="hljs-string">'close'</span>)
    ended = <span class="hljs-literal">true</span>
  }
  <span class="hljs-keyword">return</span> stream
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>map sync</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.mapSync = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sync</span>) </span>{ 
  <span class="hljs-keyword">return</span> es.through(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">var</span> mappedData = sync(data)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mappedData !== <span class="hljs-string">'undefined'</span>)
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, mappedData)
  })
}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>log just print out what is coming through the stream, for debugging</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> es.through(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>)
    <span class="hljs-keyword">if</span>(name) <span class="hljs-built_in">console</span>.error(name, data)
    <span class="hljs-keyword">else</span>     <span class="hljs-built_in">console</span>.error(data)
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, data)
  })
}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>child – pipe through a child process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.child = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) </span>{

  <span class="hljs-keyword">return</span> es.duplex(child.stdin, child.stdout)

}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>parse</p>
<p>must be used after es.split() to ensure that each chunk represents a line
source.pipe(es.split()).pipe(es.parse())</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">var</span> emitError = !!(options ? options.error : <span class="hljs-literal">false</span>)
  <span class="hljs-keyword">return</span> es.through(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">var</span> obj
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span>(data) <span class="hljs-comment">//ignore empty lines</span>
        obj = <span class="hljs-built_in">JSON</span>.parse(data.toString())
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">if</span> (emitError)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err)
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(err, <span class="hljs-string">'attemping to parse:'</span>, data)
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>ignore lines that where only whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span>(obj !== <span class="hljs-literal">undefined</span>)
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, obj)
  })
}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>stringify</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-keyword">var</span> Buffer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'buffer'</span>).Buffer
  <span class="hljs-keyword">return</span> es.mapSync(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>)</span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(Buffer.isBuffer(e) ? e.toString() : e) + <span class="hljs-string">'\n'</span>
  }) 
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>replace a string within a stream.</p>
<p>warn: just concatenates the string and then does str.split().join(). 
probably not optimal.
for smallish responses, who cares?
I need this for shadow-npm so it’s only relatively small json files.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">from, to</span>) </span>{
  <span class="hljs-keyword">return</span> es.pipeline(es.split(from), es.join(to))
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>join chunks with a joiner. just like Array#join
also accepts a callback that is passed the chunks appended together
this is still supported for legacy reasons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>legacy api</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span>(<span class="hljs-string">'function'</span> === <span class="hljs-keyword">typeof</span> str)
    <span class="hljs-keyword">return</span> es.wait(str)

  <span class="hljs-keyword">var</span> first = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">return</span> es.through(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-keyword">if</span>(!first)
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, str)
    first = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, data)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  })
}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>wait. callback when ‘end’ is emitted, with all chunks appended as string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
es.wait = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">var</span> arr = []
  <span class="hljs-keyword">return</span> es.through(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{ arr.push(data) },
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> body = Buffer.isBuffer(arr[<span class="hljs-number">0</span>]) ? Buffer.concat(arr)
        : arr.join(<span class="hljs-string">''</span>)
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'data'</span>, body)
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'end'</span>)
      <span class="hljs-keyword">if</span>(callback) callback(<span class="hljs-literal">null</span>, body)
    })
}

es.pipeable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'[EVENT-STREAM] es.pipeable is deprecated'</span>)
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
