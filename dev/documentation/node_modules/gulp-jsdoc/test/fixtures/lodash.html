<!DOCTYPE html>

<html>
<head>
  <title>lodash.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>lodash.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * @license
 * Lo-Dash 2.4.1 &lt;http://lodash.com/&gt;
 * Copyright 2012-2014 The Dojo Foundation &lt;http://dojofoundation.org/&gt;
 * Based on Underscore.js 1.6.0 &lt;http://underscorejs.org/LICENSE&gt;
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
 * Available under MIT license &lt;http://lodash.com/license&gt;
 */</span>
;(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">/** Used as a safe reference for `undefined` in pre ES5 environments */</span>
  <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>;

  <span class="hljs-comment">/** Used to compose bitmasks for wrapper metadata */</span>
  <span class="hljs-keyword">var</span> BIND_FLAG = <span class="hljs-number">1</span>,
      BIND_KEY_FLAG = <span class="hljs-number">2</span>,
      CURRY_FLAG = <span class="hljs-number">4</span>,
      CURRY_BOUND_FLAG = <span class="hljs-number">8</span>,
      PARTIAL_FLAG = <span class="hljs-number">16</span>,
      PARTIAL_RIGHT_FLAG = <span class="hljs-number">32</span>;

  <span class="hljs-comment">/** Used as the semantic version number */</span>
  <span class="hljs-keyword">var</span> version = <span class="hljs-string">'2.4.1'</span>;

  <span class="hljs-comment">/** Used as the property name for wrapper metadata */</span>
  <span class="hljs-keyword">var</span> expando = <span class="hljs-string">'__lodash@'</span> + version + <span class="hljs-string">'__'</span>;

  <span class="hljs-comment">/** Used to generate unique IDs */</span>
  <span class="hljs-keyword">var</span> idCounter = <span class="hljs-number">0</span>;

  <span class="hljs-comment">/** Used to match empty string literals in compiled template source */</span>
  <span class="hljs-keyword">var</span> reEmptyStringLeading = <span class="hljs-regexp">/\b__p \+= '';/g</span>,
      reEmptyStringMiddle = <span class="hljs-regexp">/\b(__p \+=) '' \+/g</span>,
      reEmptyStringTrailing = <span class="hljs-regexp">/(__e\(.*?\)|\b__t\)) \+\n'';/g</span>;

  <span class="hljs-comment">/** Used to match HTML entities and HTML characters */</span>
  <span class="hljs-keyword">var</span> reEscapedHtml = <span class="hljs-regexp">/&amp;(?:amp|lt|gt|quot|#39);/g</span>,
      reUnescapedHtml = <span class="hljs-regexp">/[&amp;&lt;&gt;"']/g</span>;

  <span class="hljs-comment">/** Used to match template delimiters */</span>
  <span class="hljs-keyword">var</span> reEscape = <span class="hljs-regexp">/&lt;%-([\s\S]+?)%&gt;/g</span>,
      reEvaluate = <span class="hljs-regexp">/&lt;%([\s\S]+?)%&gt;/g</span>,
      reInterpolate = <span class="hljs-regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>;

  <span class="hljs-comment">/**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */</span>
  <span class="hljs-keyword">var</span> reEsTemplate = <span class="hljs-regexp">/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g</span>;

  <span class="hljs-comment">/** Used to match regexp flags from their coerced string values */</span>
  <span class="hljs-keyword">var</span> reFlags = <span class="hljs-regexp">/\w*$/</span>;

  <span class="hljs-comment">/** Used to detected named functions */</span>
  <span class="hljs-keyword">var</span> reFuncName = <span class="hljs-regexp">/^\s*function[ \n\r\t]+\w/</span>;

  <span class="hljs-comment">/** Used to detect hexadecimal string values */</span>
  <span class="hljs-keyword">var</span> reHexPrefix = <span class="hljs-regexp">/^0[xX]/</span>;

  <span class="hljs-comment">/** Used to match latin-1 supplement letters */</span>
  <span class="hljs-keyword">var</span> reLatin1 = <span class="hljs-regexp">/[\xC0-\xFF]/g</span>;

  <span class="hljs-comment">/** Used to ensure capturing order of template delimiters */</span>
  <span class="hljs-keyword">var</span> reNoMatch = <span class="hljs-regexp">/($^)/</span>;

  <span class="hljs-comment">/**
   * Used to match RegExp special characters.
   * See this [article on RegExp characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */</span>
  <span class="hljs-keyword">var</span> reRegExpChars = <span class="hljs-regexp">/[.*+?^${}()|[\]\\]/g</span>;

  <span class="hljs-comment">/** Used to detect functions containing a `this` reference */</span>
  <span class="hljs-keyword">var</span> reThis = <span class="hljs-regexp">/\bthis\b/</span>;

  <span class="hljs-comment">/** Used to match unescaped characters in compiled string literals */</span>
  <span class="hljs-keyword">var</span> reUnescapedString = <span class="hljs-regexp">/['\n\r\t\u2028\u2029\\]/g</span>;

  <span class="hljs-comment">/** Used to match words to create compound words */</span>
  <span class="hljs-keyword">var</span> reWords = <span class="hljs-regexp">/[a-zA-Z0-9][a-z0-9]*/g</span>;

  <span class="hljs-comment">/** Used to detect and test whitespace */</span>
  <span class="hljs-keyword">var</span> whitespace = (</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>whitespace</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">' \t\x0B\f\xA0\ufeff'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>line terminators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">'\n\r\u2028\u2029'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>unicode category “Zs” space separators</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">'\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'</span>
  );

  <span class="hljs-comment">/** Used to assign default `context` object properties */</span>
  <span class="hljs-keyword">var</span> contextProps = [
    <span class="hljs-string">'Array'</span>, <span class="hljs-string">'Boolean'</span>, <span class="hljs-string">'Date'</span>, <span class="hljs-string">'Error'</span>, <span class="hljs-string">'Function'</span>, <span class="hljs-string">'Math'</span>, <span class="hljs-string">'Number'</span>, <span class="hljs-string">'Object'</span>,
    <span class="hljs-string">'RegExp'</span>, <span class="hljs-string">'Set'</span>, <span class="hljs-string">'String'</span>, <span class="hljs-string">'_'</span>, <span class="hljs-string">'clearTimeout'</span>, <span class="hljs-string">'document'</span>, <span class="hljs-string">'isFinite'</span>, <span class="hljs-string">'isNaN'</span>,
    <span class="hljs-string">'parseInt'</span>, <span class="hljs-string">'setTimeout'</span>, <span class="hljs-string">'TypeError'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-string">'WinRTError'</span>
  ];

  <span class="hljs-comment">/** Used to fix the JScript [[DontEnum]] bug */</span>
  <span class="hljs-keyword">var</span> shadowedProps = [
    <span class="hljs-string">'constructor'</span>, <span class="hljs-string">'hasOwnProperty'</span>, <span class="hljs-string">'isPrototypeOf'</span>, <span class="hljs-string">'propertyIsEnumerable'</span>,
    <span class="hljs-string">'toLocaleString'</span>, <span class="hljs-string">'toString'</span>, <span class="hljs-string">'valueOf'</span>
  ];

  <span class="hljs-comment">/** Used to make template sourceURLs easier to identify */</span>
  <span class="hljs-keyword">var</span> templateCounter = <span class="hljs-number">0</span>;

  <span class="hljs-comment">/** `Object#toString` result shortcuts */</span>
  <span class="hljs-keyword">var</span> argsClass = <span class="hljs-string">'[object Arguments]'</span>,
      arrayClass = <span class="hljs-string">'[object Array]'</span>,
      boolClass = <span class="hljs-string">'[object Boolean]'</span>,
      dateClass = <span class="hljs-string">'[object Date]'</span>,
      errorClass = <span class="hljs-string">'[object Error]'</span>,
      funcClass = <span class="hljs-string">'[object Function]'</span>,
      numberClass = <span class="hljs-string">'[object Number]'</span>,
      objectClass = <span class="hljs-string">'[object Object]'</span>,
      regexpClass = <span class="hljs-string">'[object RegExp]'</span>,
      stringClass = <span class="hljs-string">'[object String]'</span>;

  <span class="hljs-comment">/** Used to identify object classifications that `_.clone` supports */</span>
  <span class="hljs-keyword">var</span> cloneableClasses = {};
  cloneableClasses[funcClass] = <span class="hljs-literal">false</span>;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = <span class="hljs-literal">true</span>;

  <span class="hljs-comment">/** Used as an internal `_.debounce` options object by `_.throttle` */</span>
  <span class="hljs-keyword">var</span> debounceOptions = {
    <span class="hljs-string">'leading'</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">'maxWait'</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">'trailing'</span>: <span class="hljs-literal">false</span>
  };

  <span class="hljs-comment">/** Used as the property descriptor for wrapper metadata */</span>
  <span class="hljs-keyword">var</span> descriptor = {
    <span class="hljs-string">'configurable'</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">'enumerable'</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">'value'</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-string">'writable'</span>: <span class="hljs-literal">false</span>
  };

  <span class="hljs-comment">/**
   * Used to convert characters to HTML entities.
   *
   * Note: Though the "&gt;" character is escaped for symmetry, characters like
   * "&gt;", "`", and "/" don't require escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value.
   * See [Mathias' article](http://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   */</span>
  <span class="hljs-keyword">var</span> htmlEscapes = {
    <span class="hljs-string">'&amp;'</span>: <span class="hljs-string">'&amp;amp;'</span>,
    <span class="hljs-string">'&lt;'</span>: <span class="hljs-string">'&amp;lt;'</span>,
    <span class="hljs-string">'&gt;'</span>: <span class="hljs-string">'&amp;gt;'</span>,
    <span class="hljs-string">'"'</span>: <span class="hljs-string">'&amp;quot;'</span>,
    <span class="hljs-string">"'"</span>: <span class="hljs-string">'&amp;#39;'</span>
  };

  <span class="hljs-comment">/** Used to convert HTML entities to characters */</span>
  <span class="hljs-keyword">var</span> htmlUnescapes = {
    <span class="hljs-string">'&amp;amp;'</span>: <span class="hljs-string">'&amp;'</span>,
    <span class="hljs-string">'&amp;lt;'</span>: <span class="hljs-string">'&lt;'</span>,
    <span class="hljs-string">'&amp;gt;'</span>: <span class="hljs-string">'&gt;'</span>,
    <span class="hljs-string">'&amp;quot;'</span>: <span class="hljs-string">'"'</span>,
    <span class="hljs-string">'&amp;#39;'</span>: <span class="hljs-string">"'"</span>
  };

  <span class="hljs-comment">/**
   * Used to convert latin-1 supplement letters to basic latin (ASCII) letters.
   * See [Wikipedia](http://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * for more details.
   */</span>
  <span class="hljs-keyword">var</span> deburredLetters = {
    <span class="hljs-string">'\xC0'</span>: <span class="hljs-string">'A'</span>,  <span class="hljs-string">'\xC1'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'\xC2'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'\xC3'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'\xC4'</span>: <span class="hljs-string">'A'</span>, <span class="hljs-string">'\xC5'</span>: <span class="hljs-string">'A'</span>,
    <span class="hljs-string">'\xE0'</span>: <span class="hljs-string">'a'</span>,  <span class="hljs-string">'\xE1'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'\xE2'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'\xE3'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'\xE4'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'\xE5'</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-string">'\xC7'</span>: <span class="hljs-string">'C'</span>,  <span class="hljs-string">'\xE7'</span>: <span class="hljs-string">'c'</span>,
    <span class="hljs-string">'\xD0'</span>: <span class="hljs-string">'D'</span>,  <span class="hljs-string">'\xF0'</span>: <span class="hljs-string">'d'</span>,
    <span class="hljs-string">'\xC8'</span>: <span class="hljs-string">'E'</span>,  <span class="hljs-string">'\xC9'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'\xCA'</span>: <span class="hljs-string">'E'</span>, <span class="hljs-string">'\xCB'</span>: <span class="hljs-string">'E'</span>,
    <span class="hljs-string">'\xE8'</span>: <span class="hljs-string">'e'</span>,  <span class="hljs-string">'\xE9'</span>: <span class="hljs-string">'e'</span>, <span class="hljs-string">'\xEA'</span>: <span class="hljs-string">'e'</span>, <span class="hljs-string">'\xEB'</span>: <span class="hljs-string">'e'</span>,
    <span class="hljs-string">'\xCC'</span>: <span class="hljs-string">'I'</span>,  <span class="hljs-string">'\xCD'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'\xCE'</span>: <span class="hljs-string">'I'</span>, <span class="hljs-string">'\xCF'</span>: <span class="hljs-string">'I'</span>,
    <span class="hljs-string">'\xEC'</span>: <span class="hljs-string">'i'</span>,  <span class="hljs-string">'\xED'</span>: <span class="hljs-string">'i'</span>, <span class="hljs-string">'\xEE'</span>: <span class="hljs-string">'i'</span>, <span class="hljs-string">'\xEF'</span>: <span class="hljs-string">'i'</span>,
    <span class="hljs-string">'\xD1'</span>: <span class="hljs-string">'N'</span>,  <span class="hljs-string">'\xF1'</span>: <span class="hljs-string">'n'</span>,
    <span class="hljs-string">'\xD2'</span>: <span class="hljs-string">'O'</span>,  <span class="hljs-string">'\xD3'</span>: <span class="hljs-string">'O'</span>, <span class="hljs-string">'\xD4'</span>: <span class="hljs-string">'O'</span>, <span class="hljs-string">'\xD5'</span>: <span class="hljs-string">'O'</span>, <span class="hljs-string">'\xD6'</span>: <span class="hljs-string">'O'</span>, <span class="hljs-string">'\xD8'</span>: <span class="hljs-string">'O'</span>,
    <span class="hljs-string">'\xF2'</span>: <span class="hljs-string">'o'</span>,  <span class="hljs-string">'\xF3'</span>: <span class="hljs-string">'o'</span>, <span class="hljs-string">'\xF4'</span>: <span class="hljs-string">'o'</span>, <span class="hljs-string">'\xF5'</span>: <span class="hljs-string">'o'</span>, <span class="hljs-string">'\xF6'</span>: <span class="hljs-string">'o'</span>, <span class="hljs-string">'\xF8'</span>: <span class="hljs-string">'o'</span>,
    <span class="hljs-string">'\xD9'</span>: <span class="hljs-string">'U'</span>,  <span class="hljs-string">'\xDA'</span>: <span class="hljs-string">'U'</span>, <span class="hljs-string">'\xDB'</span>: <span class="hljs-string">'U'</span>, <span class="hljs-string">'\xDC'</span>: <span class="hljs-string">'U'</span>,
    <span class="hljs-string">'\xF9'</span>: <span class="hljs-string">'u'</span>,  <span class="hljs-string">'\xFA'</span>: <span class="hljs-string">'u'</span>, <span class="hljs-string">'\xFB'</span>: <span class="hljs-string">'u'</span>, <span class="hljs-string">'\xFC'</span>: <span class="hljs-string">'u'</span>,
    <span class="hljs-string">'\xDD'</span>: <span class="hljs-string">'Y'</span>,  <span class="hljs-string">'\xFD'</span>: <span class="hljs-string">'y'</span>, <span class="hljs-string">'\xFF'</span>: <span class="hljs-string">'y'</span>,
    <span class="hljs-string">'\xC6'</span>: <span class="hljs-string">'AE'</span>, <span class="hljs-string">'\xE6'</span>: <span class="hljs-string">'ae'</span>,
    <span class="hljs-string">'\xDE'</span>: <span class="hljs-string">'Th'</span>, <span class="hljs-string">'\xFE'</span>: <span class="hljs-string">'th'</span>,
    <span class="hljs-string">'\xDF'</span>: <span class="hljs-string">'ss'</span>, <span class="hljs-string">'\xD7'</span>: <span class="hljs-string">' '</span>, <span class="hljs-string">'\xF7'</span>: <span class="hljs-string">' '</span>
  };

  <span class="hljs-comment">/** Used to determine if values are of the language type Object */</span>
  <span class="hljs-keyword">var</span> objectTypes = {
    <span class="hljs-string">'function'</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">'object'</span>: <span class="hljs-literal">true</span>
  };

  <span class="hljs-comment">/** Used to escape characters for inclusion in compiled string literals */</span>
  <span class="hljs-keyword">var</span> stringEscapes = {
    <span class="hljs-string">'\\'</span>: <span class="hljs-string">'\\'</span>,
    <span class="hljs-string">"'"</span>: <span class="hljs-string">"'"</span>,
    <span class="hljs-string">'\n'</span>: <span class="hljs-string">'n'</span>,
    <span class="hljs-string">'\r'</span>: <span class="hljs-string">'r'</span>,
    <span class="hljs-string">'\t'</span>: <span class="hljs-string">'t'</span>,
    <span class="hljs-string">'\u2028'</span>: <span class="hljs-string">'u2028'</span>,
    <span class="hljs-string">'\u2029'</span>: <span class="hljs-string">'u2029'</span>
  };

  <span class="hljs-comment">/** Used as a reference to the global object */</span>
  <span class="hljs-keyword">var</span> root = (objectTypes[<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>] &amp;&amp; <span class="hljs-built_in">window</span>) || <span class="hljs-keyword">this</span>;

  <span class="hljs-comment">/** Detect free variable `exports` */</span>
  <span class="hljs-keyword">var</span> freeExports = objectTypes[<span class="hljs-keyword">typeof</span> exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  <span class="hljs-comment">/** Detect free variable `module` */</span>
  <span class="hljs-keyword">var</span> freeModule = objectTypes[<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>] &amp;&amp; <span class="hljs-built_in">module</span> &amp;&amp; !<span class="hljs-built_in">module</span>.nodeType &amp;&amp; <span class="hljs-built_in">module</span>;

  <span class="hljs-comment">/** Detect free variable `global` from Node.js or Browserified code and use it as `root` */</span>
  <span class="hljs-keyword">var</span> freeGlobal = freeExports &amp;&amp; freeModule &amp;&amp; <span class="hljs-keyword">typeof</span> global == <span class="hljs-string">'object'</span> &amp;&amp; global;
  <span class="hljs-keyword">if</span> (freeGlobal &amp;&amp; (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  <span class="hljs-comment">/** Detect the popular CommonJS extension `module.exports` */</span>
  <span class="hljs-keyword">var</span> moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports &amp;&amp; freeExports;

  <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/**
   * The base implementation of `compareAscending` used to compare values and
   * sort them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} a The value to compare to `b`.
   * @param {*} b The value to compare to `a`.
   * @returns {number} Returns the sort order indicator for `a`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCompareAscending</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (a !== b) {
      <span class="hljs-keyword">if</span> (a &gt; b || <span class="hljs-keyword">typeof</span> a == <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">if</span> (a &lt; b || <span class="hljs-keyword">typeof</span> b == <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">/**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseIndexOf</span>(<span class="hljs-params">array, value, fromIndex</span>) </span>{
    <span class="hljs-keyword">var</span> index = (fromIndex || <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>,
        length = array ? array.length : <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (++index &lt; length) {
      <span class="hljs-keyword">if</span> (array[index] === value) {
        <span class="hljs-keyword">return</span> index;
      }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">/**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cacheIndexOf</span>(<span class="hljs-params">cache, value</span>) </span>{
    <span class="hljs-keyword">return</span> cache.has(value) ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">/**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charAtCallback</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> value.charCodeAt(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">/**
   * Gets the index of the first character of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charsLeftIndex</span>(<span class="hljs-params">string, chars</span>) </span>{
    <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
        length = string.length;

    <span class="hljs-keyword">while</span> (++index &lt; length) {
      <span class="hljs-keyword">if</span> (chars.indexOf(string.charAt(index)) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> index;
  }

  <span class="hljs-comment">/**
   * Gets the index of the last character of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">charsRightIndex</span>(<span class="hljs-params">string, chars</span>) </span>{
    <span class="hljs-keyword">var</span> index = string.length;
    <span class="hljs-keyword">while</span> (index--) {
      <span class="hljs-keyword">if</span> (chars.indexOf(string.charAt(index)) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> index;
  }

  <span class="hljs-comment">/**
   * Used by `sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator for `a`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareAscending</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> baseCompareAscending(a.criteria, b.criteria) || a.index - b.index;
  }

  <span class="hljs-comment">/**
   * Used by `sortBy` to compare multiple properties of each element in a
   * collection and stable sort them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator for `a`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareMultipleAscending</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">var</span> ac = a.criteria,
        bc = b.criteria,
        index = -<span class="hljs-number">1</span>,
        length = ac.length;

    <span class="hljs-keyword">while</span> (++index &lt; length) {
      <span class="hljs-keyword">var</span> result = baseCompareAscending(ac[index], bc[index]);
      <span class="hljs-keyword">if</span> (result) {
        <span class="hljs-keyword">return</span> result;
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Fixes an <code>Array#sort</code> bug in the JS engine embedded in Adobe applications
that causes it, under certain circumstances, to provided the same value
for <code>a</code> and <code>b</code>. See <a href="https://github.com/jashkenas/underscore/pull/1247">https://github.com/jashkenas/underscore/pull/1247</a></p>
<p>This also ensures a stable sort in V8 and other engines.
See <a href="https://code.google.com/p/v8/issues/detail?id=90">https://code.google.com/p/v8/issues/detail?id=90</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> a.index - b.index;
  }

  <span class="hljs-comment">/**
   * Creates a function that produces compound words out of the words in a
   * given string.
   *
   * @private
   * @param {Function} callback The function called to combine each word.
   * @returns {Function} Returns the new compounder function.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCompounder</span>(<span class="hljs-params">callback</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          words = string != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">String</span>(string).replace(reLatin1, deburrLetter).match(reWords),
          length = words ? words.length : <span class="hljs-number">0</span>,
          result = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        result = callback(result, words[index], index, words);
      }
      <span class="hljs-keyword">return</span> result;
    };
  }

  <span class="hljs-comment">/**
   * Used by `createCompounder` to convert latin-1 supplement letters to basic
   * latin (ASCII) letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deburrLetter</span>(<span class="hljs-params">letter</span>) </span>{
    <span class="hljs-keyword">return</span> deburredLetters[letter];
  }

  <span class="hljs-comment">/**
   * Used by `escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeHtmlChar</span>(<span class="hljs-params">chr</span>) </span>{
    <span class="hljs-keyword">return</span> htmlEscapes[chr];
  }

  <span class="hljs-comment">/**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeStringChar</span>(<span class="hljs-params">chr</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'\\'</span> + stringEscapes[chr];
  }

  <span class="hljs-comment">/**
   * Checks if `value` is a DOM node in IE &lt; 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNode</span>(<span class="hljs-params">value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>IE &lt; 9 presents DOM nodes as <code>Object</code> objects except they have <code>toString</code>
methods that are <code>typeof</code> “string” and still can coerce nodes to strings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value.toString != <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> (value + <span class="hljs-string">''</span>) == <span class="hljs-string">'string'</span>;
  }

  <span class="hljs-comment">/**
   * A fallback implementation of `trim` to remove leading and trailing
   * whitespace or specified characters from `string`.
   *
   * @private
   * @param {string} string The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @returns {string} Returns the trimmed string.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shimTrim</span>(<span class="hljs-params">string, chars</span>) </span>{
    string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
    <span class="hljs-keyword">if</span> (!string) {
      <span class="hljs-keyword">return</span> string;
    }
    <span class="hljs-keyword">if</span> (chars == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + <span class="hljs-number">1</span>);
    }
    chars = <span class="hljs-built_in">String</span>(chars);
    <span class="hljs-keyword">return</span> string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + <span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">/**
   * A fallback implementation of `trimLeft` to remove leading whitespace or
   * specified characters from `string`.
   *
   * @private
   * @param {string} string The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @returns {string} Returns the trimmed string.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shimTrimLeft</span>(<span class="hljs-params">string, chars</span>) </span>{
    string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
    <span class="hljs-keyword">if</span> (!string) {
      <span class="hljs-keyword">return</span> string;
    }
    <span class="hljs-keyword">if</span> (chars == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> string.slice(trimmedLeftIndex(string))
    }
    chars = <span class="hljs-built_in">String</span>(chars);
    <span class="hljs-keyword">return</span> string.slice(charsLeftIndex(string, chars));
  }

  <span class="hljs-comment">/**
   * A fallback implementation of `trimRight` to remove trailing whitespace or
   * specified characters from `string`.
   *
   * @private
   * @param {string} string The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @returns {string} Returns the trimmed string.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shimTrimRight</span>(<span class="hljs-params">string, chars</span>) </span>{
    string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
    <span class="hljs-keyword">if</span> (!string) {
      <span class="hljs-keyword">return</span> string;
    }
    <span class="hljs-keyword">if</span> (chars == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> string.slice(<span class="hljs-number">0</span>, trimmedRightIndex(string) + <span class="hljs-number">1</span>)
    }
    chars = <span class="hljs-built_in">String</span>(chars);
    <span class="hljs-keyword">return</span> string.slice(<span class="hljs-number">0</span>, charsRightIndex(string, chars) + <span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">/**
   * Gets the index of the first non-whitespace character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimmedLeftIndex</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
        length = string.length;

    <span class="hljs-keyword">while</span> (++index &lt; length) {
      <span class="hljs-keyword">var</span> c = string.charCodeAt(index);
      <span class="hljs-keyword">if</span> (!((c &lt;= <span class="hljs-number">160</span> &amp;&amp; (c &gt;= <span class="hljs-number">9</span> &amp;&amp; c &lt;= <span class="hljs-number">13</span>) || c == <span class="hljs-number">32</span> || c == <span class="hljs-number">160</span>) || c == <span class="hljs-number">5760</span> || c == <span class="hljs-number">6158</span> ||
          (c &gt;= <span class="hljs-number">8192</span> &amp;&amp; (c &lt;= <span class="hljs-number">8202</span> || c == <span class="hljs-number">8232</span> || c == <span class="hljs-number">8233</span> || c == <span class="hljs-number">8239</span> || c == <span class="hljs-number">8287</span> || c == <span class="hljs-number">12288</span> || c == <span class="hljs-number">65279</span>)))) {
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> index;
  }

  <span class="hljs-comment">/**
   * Gets the index of the last non-whitespace character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimmedRightIndex</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">var</span> index = string.length;
    <span class="hljs-keyword">while</span> (index--) {
      <span class="hljs-keyword">var</span> c = string.charCodeAt(index);
      <span class="hljs-keyword">if</span> (!((c &lt;= <span class="hljs-number">160</span> &amp;&amp; (c &gt;= <span class="hljs-number">9</span> &amp;&amp; c &lt;= <span class="hljs-number">13</span>) || c == <span class="hljs-number">32</span> || c == <span class="hljs-number">160</span>) || c == <span class="hljs-number">5760</span> || c == <span class="hljs-number">6158</span> ||
          (c &gt;= <span class="hljs-number">8192</span> &amp;&amp; (c &lt;= <span class="hljs-number">8202</span> || c == <span class="hljs-number">8232</span> || c == <span class="hljs-number">8233</span> || c == <span class="hljs-number">8239</span> || c == <span class="hljs-number">8287</span> || c == <span class="hljs-number">12288</span> || c == <span class="hljs-number">65279</span>)))) {
        <span class="hljs-keyword">break</span>;
      }
    }
    <span class="hljs-keyword">return</span> index;
  }

  <span class="hljs-comment">/**
   * Used by `unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unescapeHtmlChar</span>(<span class="hljs-params">chr</span>) </span>{
    <span class="hljs-keyword">return</span> htmlUnescapes[chr];
  }

  <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

  <span class="hljs-comment">/**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runInContext</span>(<span class="hljs-params">context</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Avoid issues with some ES3 environments that attempt to use values, named
after built-in constructors like <code>Object</code>, for the creation of literals.
ES5 clears this up by stating that literals must use built-in constructors.
See <a href="http://es5.github.io/#x11.1.5">http://es5.github.io/#x11.1.5</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    <span class="hljs-comment">/** Native constructor references */</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">Array</span> = context.Array,
        <span class="hljs-built_in">Boolean</span> = context.Boolean,
        <span class="hljs-built_in">Date</span> = context.Date,
        <span class="hljs-built_in">Error</span> = context.Error,
        <span class="hljs-built_in">Function</span> = context.Function,
        <span class="hljs-built_in">Math</span> = context.Math,
        <span class="hljs-built_in">Number</span> = context.Number,
        <span class="hljs-built_in">Object</span> = context.Object,
        <span class="hljs-built_in">RegExp</span> = context.RegExp,
        <span class="hljs-built_in">String</span> = context.String,
        <span class="hljs-built_in">TypeError</span> = context.TypeError;

    <span class="hljs-comment">/** Used for native method references */</span>
    <span class="hljs-keyword">var</span> arrayRef = <span class="hljs-built_in">Array</span>.prototype,
        errorProto = <span class="hljs-built_in">Error</span>.prototype,
        objectProto = <span class="hljs-built_in">Object</span>.prototype,
        stringProto = <span class="hljs-built_in">String</span>.prototype;

    <span class="hljs-comment">/** Used to detect DOM support */</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">document</span> = (<span class="hljs-built_in">document</span> = context.window) &amp;&amp; <span class="hljs-built_in">document</span>.document;

    <span class="hljs-comment">/** Used to restore the original `_` reference in `noConflict` */</span>
    <span class="hljs-keyword">var</span> oldDash = context._;

    <span class="hljs-comment">/** Used to resolve the internal [[Class]] of values */</span>
    <span class="hljs-keyword">var</span> toString = objectProto.toString;

    <span class="hljs-comment">/** Used to detect if a method is native */</span>
    <span class="hljs-keyword">var</span> reNative = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> +
      escapeRegExp(toString)
      .replace(<span class="hljs-regexp">/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g</span>, <span class="hljs-string">'$1.*?'</span>) + <span class="hljs-string">'$'</span>
    );

    <span class="hljs-comment">/** Native method shortcuts */</span>
    <span class="hljs-keyword">var</span> ceil = <span class="hljs-built_in">Math</span>.ceil,
        clearTimeout = context.clearTimeout,
        floor = <span class="hljs-built_in">Math</span>.floor,
        fnToString = <span class="hljs-built_in">Function</span>.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = <span class="hljs-built_in">Object</span>.getPrototypeOf) &amp;&amp; getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        <span class="hljs-built_in">Set</span> = isNative(<span class="hljs-built_in">Set</span> = context.Set) &amp;&amp; <span class="hljs-built_in">Set</span>,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    <span class="hljs-comment">/** Used to set meta data on functions */</span>
    <span class="hljs-keyword">var</span> defineProperty = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>IE 8 only accepts DOM elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> o = {},
            func = isNative(func = <span class="hljs-built_in">Object</span>.defineProperty) &amp;&amp; func,
            result = func(o, o, o) &amp;&amp; func;
      } <span class="hljs-keyword">catch</span>(e) { }
      <span class="hljs-keyword">return</span> result;
    }());

    <span class="hljs-comment">/* Native method shortcuts for methods with the same name as other `lodash` methods */</span>
    <span class="hljs-keyword">var</span> nativeContains = isNative(nativeContains = stringProto.contains) &amp;&amp; nativeContains,
        nativeCreate = isNative(nativeCreate = <span class="hljs-built_in">Object</span>.create) &amp;&amp; nativeCreate,
        nativeIsArray = isNative(nativeIsArray = <span class="hljs-built_in">Array</span>.isArray) &amp;&amp; nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = <span class="hljs-built_in">Object</span>.keys) &amp;&amp; nativeKeys,
        nativeMax = <span class="hljs-built_in">Math</span>.max,
        nativeMin = <span class="hljs-built_in">Math</span>.min,
        nativeNow = isNative(nativeNow = <span class="hljs-built_in">Date</span>.now) &amp;&amp; nativeNow,
        nativeParseInt = context.parseInt,
        nativeRandom = <span class="hljs-built_in">Math</span>.random,
        nativeTrim = isNative(nativeTrim = stringProto.trim) &amp;&amp; !nativeTrim.call(whitespace) &amp;&amp; nativeTrim,
        nativeTrimLeft = isNative(nativeTrimLeft = stringProto.trimLeft) &amp;&amp; !nativeTrimLeft.call(whitespace) &amp;&amp; nativeTrimLeft,
        nativeTrimRight = isNative(nativeTrimRight = stringProto.trimRight) &amp;&amp; !nativeTrimRight.call(whitespace) &amp;&amp; nativeTrimRight;

    <span class="hljs-comment">/** Used to lookup a built-in constructor by [[Class]] */</span>
    <span class="hljs-keyword">var</span> ctorByClass = {};
    ctorByClass[arrayClass] = <span class="hljs-built_in">Array</span>;
    ctorByClass[boolClass] = <span class="hljs-built_in">Boolean</span>;
    ctorByClass[dateClass] = <span class="hljs-built_in">Date</span>;
    ctorByClass[funcClass] = <span class="hljs-built_in">Function</span>;
    ctorByClass[objectClass] = <span class="hljs-built_in">Object</span>;
    ctorByClass[numberClass] = <span class="hljs-built_in">Number</span>;
    ctorByClass[regexpClass] = <span class="hljs-built_in">RegExp</span>;
    ctorByClass[stringClass] = <span class="hljs-built_in">String</span>;

    <span class="hljs-comment">/** Used to avoid iterating non-enumerable properties in IE &lt; 9 */</span>
    <span class="hljs-keyword">var</span> nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { <span class="hljs-string">'constructor'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'toLocaleString'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'toString'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'valueOf'</span>: <span class="hljs-literal">true</span> };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { <span class="hljs-string">'constructor'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'toString'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'valueOf'</span>: <span class="hljs-literal">true</span> };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { <span class="hljs-string">'constructor'</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">'toString'</span>: <span class="hljs-literal">true</span> };
    nonEnumProps[objectClass] = { <span class="hljs-string">'constructor'</span>: <span class="hljs-literal">true</span> };

    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> length = shadowedProps.length;
      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">var</span> key = shadowedProps[length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> className <span class="hljs-keyword">in</span> nonEnumProps) {
          <span class="hljs-keyword">if</span> (hasOwnProperty.call(nonEnumProps, className) &amp;&amp; !hasOwnProperty.call(nonEnumProps[className], key)) {
            nonEnumProps[className][key] = <span class="hljs-literal">false</span>;
          }
        }
      }
    }());

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `at`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `constant`, `countBy`, `create`, `createCallback`,
     * `curry`, `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`,
     * `flatten`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
     * `forOwnRight`, `functions`, `groupBy`, `indexBy`, `initial`, `intersection`,
     * `invert`, `invoke`, `keys`, `map`, `mapValues`, `matches`, `max`, `memoize`,
     * `merge`, `min`, `noop`, `object`, `omit`, `once`, `pairs`, `partial`,
     * `partialRight`, `pick`, `pluck`, `property`, `pull`, `push`, `range`,
     * `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`,
     * `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`, `union`,
     * `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`, `xor`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `capitalize`, `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`,
     * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`,
     * `identity`, `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`,
     * `isElement`, `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`,
     * `isNull`, `isNumber`, `isObject`, `isPlainObject`, `isRegExp`, `isString`,
     * `isUndefined`, `join`, `lastIndexOf`, `mixin`, `noConflict`, `now`,
     * `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `result`, `shift`,
     * `size`, `some`, `sortedIndex`, `runInContext`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first`, `last`, and `sample` return wrapped values
     * when `n` is provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // =&gt; 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // =&gt; false
     *
     * _.isArray(squares.value());
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lodash</span>(<span class="hljs-params">value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>don’t wrap if already wrapped, even if wrapped by a different <code>lodash</code> constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; !isArray(value) &amp;&amp; hasOwnProperty.call(value, <span class="hljs-string">'__wrapped__'</span>))
       ? value
       : <span class="hljs-keyword">new</span> lodashWrapper(value);
    }

    <span class="hljs-comment">/**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} [chainAll=false] A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lodashWrapper</span>(<span class="hljs-params">value, chainAll</span>) </span>{
      <span class="hljs-keyword">this</span>.__chain__ = !!chainAll;
      <span class="hljs-keyword">this</span>.__wrapped__ = value;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>ensure <code>new lodashWrapper</code> is an instance of <code>lodash</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodashWrapper.prototype = lodash.prototype;

    <span class="hljs-comment">/**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */</span>
    <span class="hljs-keyword">var</span> support = lodash.support = {};

    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> ctor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>; },
          object = { <span class="hljs-string">'0'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'length'</span>: <span class="hljs-number">1</span> },
          props = [];

      ctor.prototype = { <span class="hljs-string">'valueOf'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">1</span> };
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> ctor) { props.push(key); }
      <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> <span class="hljs-built_in">arguments</span>) { }

      <span class="hljs-comment">/**
       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox &lt; 4, IE &lt; 9).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.argsClass = toString.call(<span class="hljs-built_in">arguments</span>) == argsClass;

      <span class="hljs-comment">/**
       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera &lt; 10.5).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.argsObject = <span class="hljs-built_in">arguments</span>.constructor == <span class="hljs-built_in">Object</span> &amp;&amp; !(<span class="hljs-built_in">arguments</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);

      <span class="hljs-comment">/**
       * Detect if `name` or `message` properties of `Error.prototype` are
       * enumerable by default. (IE &lt; 9, Safari &lt; 5.1)
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, <span class="hljs-string">'message'</span>) || propertyIsEnumerable.call(errorProto, <span class="hljs-string">'name'</span>);

      <span class="hljs-comment">/**
       * Detect if `prototype` properties are enumerable by default.
       *
       * Firefox &lt; 3.6, Opera &gt; 9.50 - Opera &lt; 11.60, and Safari &lt; 5.1
       * (if the prototype or a property on the prototype has been set)
       * incorrectly sets a function's `prototype` property [[Enumerable]]
       * value to `true`.
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.enumPrototypes = propertyIsEnumerable.call(ctor, <span class="hljs-string">'prototype'</span>);

      <span class="hljs-comment">/**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but PS3 and older Opera mobile browsers &amp; avoided in Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.funcDecomp = !isNative(context.WinRTError) &amp;&amp; reThis.test(runInContext);

      <span class="hljs-comment">/**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.funcNames = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.name == <span class="hljs-string">'string'</span>;

      <span class="hljs-comment">/**
       * Detect if `arguments` object indexes are non-enumerable
       * (Firefox &lt; 4, IE &lt; 9, PhantomJS, Safari &lt; 5.1).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.nonEnumArgs = key != <span class="hljs-number">0</span>;

      <span class="hljs-comment">/**
       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
       *
       * In IE &lt; 9 an objects own properties, shadowing non-enumerable ones, are
       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.nonEnumShadows = !<span class="hljs-regexp">/valueOf/</span>.test(props);

      <span class="hljs-comment">/**
       * Detect if own properties are iterated after inherited properties (all but IE &lt; 9).
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.ownLast = props[<span class="hljs-number">0</span>] != <span class="hljs-string">'x'</span>;

      <span class="hljs-comment">/**
       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
       *
       * Firefox &lt; 10, IE compatibility mode, and IE &lt; 9 have buggy Array `shift()`
       * and `splice()` functions that fail to remove the last element, `value[0]`,
       * of array-like objects even though the `length` property is set to `0`.
       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
       * is buggy regardless of mode in IE &lt; 9 and buggy in compatibility mode in IE 9.
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.spliceObjects = (splice.call(object, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), !object[<span class="hljs-number">0</span>]);

      <span class="hljs-comment">/**
       * Detect lack of support for accessing string characters by index.
       *
       * IE &lt; 8 can't access characters by index and IE 8 can only access
       * characters by index on string literals.
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      support.unindexedChars = (<span class="hljs-string">'x'</span>[<span class="hljs-number">0</span>] + <span class="hljs-built_in">Object</span>(<span class="hljs-string">'x'</span>)[<span class="hljs-number">0</span>]) != <span class="hljs-string">'xx'</span>;

      <span class="hljs-comment">/**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      <span class="hljs-keyword">try</span> {
        support.dom = <span class="hljs-built_in">document</span>.createDocumentFragment().nodeType === <span class="hljs-number">11</span>;
      } <span class="hljs-keyword">catch</span>(e) {
        support.dom = <span class="hljs-literal">false</span>;
      }

      <span class="hljs-comment">/**
       * Detect if a DOM node's [[Class]] is resolvable (all but IE &lt; 9)
       * and that the JS engine errors when attempting to coerce an object to
       * a string without a `toString` function.
       *
       * @memberOf _.support
       * @type boolean
       */</span>
      <span class="hljs-keyword">try</span> {
        support.nodeClass = !(toString.call(<span class="hljs-built_in">document</span>) == objectClass &amp;&amp; !({ <span class="hljs-string">'toString'</span>: <span class="hljs-number">0</span> } + <span class="hljs-string">''</span>));
      } <span class="hljs-keyword">catch</span>(e) {
        support.nodeClass = <span class="hljs-literal">true</span>;
      }
    }(<span class="hljs-number">1</span>));

    <span class="hljs-comment">/**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */</span>
    lodash.templateSettings = {

      <span class="hljs-comment">/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */</span>
      <span class="hljs-string">'escape'</span>: reEscape,

      <span class="hljs-comment">/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */</span>
      <span class="hljs-string">'evaluate'</span>: reEvaluate,

      <span class="hljs-comment">/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */</span>
      <span class="hljs-string">'interpolate'</span>: reInterpolate,

      <span class="hljs-comment">/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */</span>
      <span class="hljs-string">'variable'</span>: <span class="hljs-string">''</span>,

      <span class="hljs-comment">/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */</span>
      <span class="hljs-string">'imports'</span>: {

        <span class="hljs-comment">/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */</span>
        <span class="hljs-string">'_'</span>: lodash
      }
    };

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * The template used to create iterator functions.
     *
     * @private
     * @param {Object} data The data object used to populate the text.
     * @returns {string} Returns the interpolated text.
     */</span>
    <span class="hljs-keyword">var</span> iteratorTemplate = template(</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>assign the <code>result</code> variable an initial value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'var result = &lt;%= init %&gt;;\n'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>exit early if the first argument is not an object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">"if (!isObject(object)) {\n"</span> +
      <span class="hljs-string">'  return result;\n'</span> +
      <span class="hljs-string">'}'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>add support for iterating over <code>arguments</code> objects if needed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'&lt;% if (support.nonEnumArgs) { %&gt;\n'</span> +
      <span class="hljs-string">'var length = object.length;\n'</span> +
      <span class="hljs-string">'if (length &amp;&amp; isArguments(object)) {\n'</span> +
      <span class="hljs-string">'  key = -1;\n'</span> +
      <span class="hljs-string">'  while (++key &lt; length) {\n'</span> +
      <span class="hljs-string">"    key += '';\n"</span> +
      <span class="hljs-string">'    &lt;%= loop %&gt;;\n'</span> +
      <span class="hljs-string">'  }\n'</span> +
      <span class="hljs-string">'  return result;\n'</span> +
      <span class="hljs-string">'}'</span> +
      <span class="hljs-string">'&lt;% } %&gt;'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>avoid iterating over <code>prototype</code> properties in older Firefox, Opera, and Safari</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'&lt;% if (support.enumPrototypes) { %&gt;\n'</span> +
      <span class="hljs-string">"var skipProto = typeof object == 'function';\n"</span> +
      <span class="hljs-string">'&lt;% } %&gt;'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>avoid iterating over <code>Error.prototype</code> properties in older IE and Safari</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'&lt;% if (support.enumErrorProps) { %&gt;\n'</span> +
      <span class="hljs-string">'var skipErrorProps = object === errorProto || object instanceof Error;\n'</span> +
      <span class="hljs-string">'&lt;% } %&gt;'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>define conditions used in the loop</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'&lt;%'</span> +
      <span class="hljs-string">'var conditions = [];\n'</span> +
      <span class="hljs-string">"if (support.enumPrototypes) { conditions.push('!(skipProto &amp;&amp; key == \\'prototype\\')'); }\n"</span> +
      <span class="hljs-string">"if (support.enumErrorProps) { conditions.push('!(skipErrorProps &amp;&amp; (key == \\'message\\' || key == \\'name\\'))'); }"</span> +
      <span class="hljs-string">'%&gt;\n'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>iterate over the object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'for (var key in object) {\n&lt;%'</span> +
      <span class="hljs-string">"  if (useHas) { conditions.push('hasOwnProperty.call(object, key)'); }\n"</span> +
      <span class="hljs-string">"  if (conditions.length) { %&gt;  if (&lt;%= conditions.join(' &amp;&amp; ') %&gt;) {\n  &lt;% } %&gt;"</span> +
      <span class="hljs-string">'  &lt;%= loop %&gt;;'</span> +
      <span class="hljs-string">'  &lt;% if (conditions.length) { %&gt;\n  }&lt;% } %&gt;\n'</span> +
      <span class="hljs-string">'}\n'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Lo-Dash skips the <code>constructor</code> property when it infers it’s iterating
over a <code>prototype</code> object because IE &lt; 9 can’t set the <code>[[Enumerable]]</code>
attribute of an existing property and the <code>constructor</code> property of a
prototype defaults to non-enumerable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">'&lt;% if (support.nonEnumShadows) { %&gt;\n'</span> +
      <span class="hljs-string">'if (object !== objectProto) {\n'</span> +
      <span class="hljs-string">"  var ctor = object.constructor,\n"</span> +
      <span class="hljs-string">'      isProto = object === (ctor &amp;&amp; ctor.prototype),\n'</span> +
      <span class="hljs-string">'      className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),\n'</span> +
      <span class="hljs-string">'      nonEnum = nonEnumProps[className];\n'</span> +
      <span class="hljs-string">'  &lt;% for (var index = 0; index &lt; 7; index++) { %&gt;\n'</span> +
      <span class="hljs-string">"  key = '&lt;%= shadowedProps[index] %&gt;';\n"</span> +
      <span class="hljs-string">'  if ((!(isProto &amp;&amp; nonEnum[key]) &amp;&amp; hasOwnProperty.call(object, key))&lt;%'</span> +
      <span class="hljs-string">'      if (!useHas) { %&gt; || (!nonEnum[key] &amp;&amp; object[key] !== objectProto[key])&lt;% }'</span> +
      <span class="hljs-string">'    %&gt;) {\n'</span> +
      <span class="hljs-string">'    &lt;%= loop %&gt;;\n'</span> +
      <span class="hljs-string">'  }'</span> +
      <span class="hljs-string">'  &lt;% } %&gt;\n'</span> +
      <span class="hljs-string">'}'</span> +
      <span class="hljs-string">'&lt;% } %&gt;\n'</span> +

      <span class="hljs-string">'return result;'</span>
    );

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} data The metadata array.
     * @returns {Function} Returns the new bound function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseBind</span>(<span class="hljs-params">data</span>) </span>{
      <span class="hljs-keyword">var</span> func = data[<span class="hljs-number">0</span>],
          thisArg = data[<span class="hljs-number">3</span>],
          partialArgs = data[<span class="hljs-number">4</span>],
          partialHolders = data[<span class="hljs-number">6</span>];

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bound</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>Function#bind</code> spec
<a href="http://es5.github.io/#x15.3.4.5">http://es5.github.io/#x15.3.4.5</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (partialArgs) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>avoid <code>arguments</code> object use disqualifying optimizations by
converting it to an array before passing it to <code>composeArgs</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
               length = <span class="hljs-built_in">arguments</span>.length,
               args = <span class="hljs-built_in">Array</span>(length);

          <span class="hljs-keyword">while</span> (++index &lt; length) {
            args[index] = <span class="hljs-built_in">arguments</span>[index];
          }
          args = composeArgs(partialArgs, partialHolders, args);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>mimic the constructor’s <code>return</code> behavior
<a href="http://es5.github.io/#x13.2.2">http://es5.github.io/#x13.2.2</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> bound) {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>ensure <code>new bound</code> is an instance of <code>func</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || <span class="hljs-built_in">arguments</span>);

          <span class="hljs-keyword">return</span> isObject(result) ? result : thisBinding;
        }
        <span class="hljs-keyword">return</span> func.apply(thisArg, args || <span class="hljs-built_in">arguments</span>);
      }
      setData(bound, data);
      <span class="hljs-keyword">return</span> bound;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseClone</span>(<span class="hljs-params">value, isDeep, callback, stackA, stackB</span>) </span>{
      <span class="hljs-keyword">if</span> (callback) {
        <span class="hljs-keyword">var</span> result = callback(value);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result != <span class="hljs-string">'undefined'</span>) {
          <span class="hljs-keyword">return</span> result;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>inspect [[Class]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> isObj = isObject(value);
      <span class="hljs-keyword">if</span> (isObj) {
        <span class="hljs-keyword">var</span> className = toString.call(value);
        <span class="hljs-keyword">if</span> (!cloneableClasses[className] || (!support.nodeClass &amp;&amp; isNode(value))) {
          <span class="hljs-keyword">return</span> value;
        }
        <span class="hljs-keyword">var</span> ctor = ctorByClass[className];
        <span class="hljs-keyword">switch</span> (className) {
          <span class="hljs-keyword">case</span> boolClass:
          <span class="hljs-keyword">case</span> dateClass:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ctor(+value);

          <span class="hljs-keyword">case</span> numberClass:
          <span class="hljs-keyword">case</span> stringClass:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ctor(value);

          <span class="hljs-keyword">case</span> regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            <span class="hljs-keyword">return</span> result;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> value;
      }
      <span class="hljs-keyword">var</span> isArr = isArray(value);
      <span class="hljs-keyword">if</span> (isDeep) {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>check for circular references and return corresponding clone</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);

        <span class="hljs-keyword">var</span> length = stackA.length;
        <span class="hljs-keyword">while</span> (length--) {
          <span class="hljs-keyword">if</span> (stackA[length] == value) {
            <span class="hljs-keyword">return</span> stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      <span class="hljs-keyword">else</span> {
        result = isArr ? slice(value) : assign({}, value);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>add array properties assigned by <code>RegExp#exec</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isArr) {
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(value, <span class="hljs-string">'index'</span>)) {
          result.index = value.index;
        }
        <span class="hljs-keyword">if</span> (hasOwnProperty.call(value, <span class="hljs-string">'input'</span>)) {
          result.input = value.input;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>exit for shallow clone</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!isDeep) {
        <span class="hljs-keyword">return</span> result;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>add the source value to the stack of traversed objects
and associate it with its clone</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      stackA.push(value);
      stackB.push(result);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>recursively populate clone (susceptible to call stack limits)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (isArr ? baseEach : baseForOwn)(value, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">objValue, key</span>) </span>{
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCreate</span>(<span class="hljs-params">prototype</span>) </span>{
      <span class="hljs-keyword">return</span> isObject(prototype) ? nativeCreate(prototype) : {};
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>fallback for environments without <code>Object.create</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!nativeCreate) {
      baseCreate = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object</span>(<span class="hljs-params"></span>) </span>{}
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prototype</span>) </span>{
          <span class="hljs-keyword">if</span> (isObject(prototype)) {
            <span class="hljs-built_in">Object</span>.prototype = prototype;
            <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;
            <span class="hljs-built_in">Object</span>.prototype = <span class="hljs-literal">null</span>;
          }
          <span class="hljs-keyword">return</span> result || context.Object();
        };
      }());
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCreateCallback</span>(<span class="hljs-params">func, thisArg, argCount</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func != <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> identity;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>exit early for no <code>thisArg</code> or already bound by <code>Function#bind</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> || !(<span class="hljs-string">'prototype'</span> <span class="hljs-keyword">in</span> func)) {
        <span class="hljs-keyword">return</span> func;
      }
      <span class="hljs-keyword">var</span> data = func[expando];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data == <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">if</span> (support.funcNames) {
          data = !func.name;
        }
        data = data || !support.funcDecomp;
        <span class="hljs-keyword">if</span> (!data) {
          <span class="hljs-keyword">var</span> source = fnToString.call(func);
          <span class="hljs-keyword">if</span> (!support.funcNames) {
            data = !reFuncName.test(source);
          }
          <span class="hljs-keyword">if</span> (!data) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>checks if <code>func</code> references the <code>this</code> keyword and stores the result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            data = reThis.test(source);
            setData(func, data);
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>exit early if there are no <code>this</code> references or <code>func</code> is bound</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (data === <span class="hljs-literal">false</span> || (data !== <span class="hljs-literal">true</span> &amp;&amp; data[<span class="hljs-number">1</span>] &amp; BIND_FLAG)) {
        <span class="hljs-keyword">return</span> func;
      }
      <span class="hljs-keyword">switch</span> (argCount) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
          <span class="hljs-keyword">return</span> func.call(thisArg, value);
        };
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
          <span class="hljs-keyword">return</span> func.call(thisArg, a, b);
        };
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">return</span> func.call(thisArg, value, index, collection);
        };
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, value, index, collection</span>) </span>{
          <span class="hljs-keyword">return</span> func.call(thisArg, accumulator, value, index, collection);
        };
      }
      <span class="hljs-keyword">return</span> bind(func, thisArg);
    }

    <span class="hljs-comment">/**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} data The metadata array.
     * @returns {Function} Returns the new function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCreateWrapper</span>(<span class="hljs-params">data</span>) </span>{
      <span class="hljs-keyword">var</span> func = data[<span class="hljs-number">0</span>],
          bitmask = data[<span class="hljs-number">1</span>],
          arity = data[<span class="hljs-number">2</span>],
          thisArg = data[<span class="hljs-number">3</span>],
          partialArgs = data[<span class="hljs-number">4</span>],
          partialRightArgs = data[<span class="hljs-number">5</span>],
          partialHolders = data[<span class="hljs-number">6</span>],
          partialRightHolders = data[<span class="hljs-number">7</span>];

      <span class="hljs-keyword">var</span> isBind = bitmask &amp; BIND_FLAG,
          isBindKey = bitmask &amp; BIND_KEY_FLAG,
          isCurry = bitmask &amp; CURRY_FLAG,
          isCurryBound = bitmask &amp; CURRY_BOUND_FLAG,
          key = func;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bound</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = <span class="hljs-built_in">arguments</span>.length,
            args = <span class="hljs-built_in">Array</span>(length);

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          args[index] = <span class="hljs-built_in">arguments</span>[index];
        }
        <span class="hljs-keyword">if</span> (partialArgs) {
          args = composeArgs(partialArgs, partialHolders, args);
        }
        <span class="hljs-keyword">if</span> (partialRightArgs) {
          args = composeArgsRight(partialRightArgs, partialRightHolders, args);
        }
        <span class="hljs-keyword">if</span> (isCurry &amp;&amp; length &lt; arity) {
          bitmask |= PARTIAL_FLAG;
          bitmask &amp;= ~PARTIAL_RIGHT_FLAG
          <span class="hljs-keyword">if</span> (!isCurryBound) {
            bitmask &amp;= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          <span class="hljs-keyword">var</span> newArity = nativeMax(<span class="hljs-number">0</span>, arity - length);
          <span class="hljs-keyword">return</span> baseCreateWrapper([func, bitmask, newArity, thisArg, args, <span class="hljs-literal">null</span>, []]);
        }
        <span class="hljs-keyword">var</span> thisBinding = isBind ? thisArg : <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span> (isBindKey) {
          func = thisBinding[key];
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> bound) {
          thisBinding = baseCreate(func.prototype);
          <span class="hljs-keyword">var</span> result = func.apply(thisBinding, args);
          <span class="hljs-keyword">return</span> isObject(result) ? result : thisBinding;
        }
        <span class="hljs-keyword">return</span> func.apply(thisBinding, args);
      }
      setData(bound, data);
      <span class="hljs-keyword">return</span> bound;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseDifference</span>(<span class="hljs-params">array, values</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!length) {
        <span class="hljs-keyword">return</span> [];
      }
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          indexOf = getIndexOf(),
          prereq = indexOf === baseIndexOf,
          isLarge = prereq &amp;&amp; createCache &amp;&amp; values &amp;&amp; values.length &gt;= <span class="hljs-number">200</span>,
          isCommon = prereq &amp;&amp; !isLarge,
          result = [],
          valuesLength = values ? values.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (isLarge) {
        indexOf = cacheIndexOf;
        values = createCache(values);
      }
      outer:
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> value = array[index];

        <span class="hljs-keyword">if</span> (isCommon) {
          <span class="hljs-keyword">var</span> valuesIndex = valuesLength;
          <span class="hljs-keyword">while</span> (valuesIndex--) {
            <span class="hljs-keyword">if</span> (values[valuesIndex] === value) {
              <span class="hljs-keyword">continue</span> outer;
            }
          }
          result.push(value);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indexOf(values, value) &lt; <span class="hljs-number">0</span>) {
          result.push(value);
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.forEach` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseEach</span>(<span class="hljs-params">collection, callback</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          iterable = collection,
          length = collection ? collection.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">if</span> (support.unindexedChars &amp;&amp; isString(iterable)) {
          iterable = iterable.split(<span class="hljs-string">''</span>);
        }
        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">if</span> (callback(iterable[index], index, collection) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseForOwn(collection, callback);
      }
      <span class="hljs-keyword">return</span> collection;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseEachRight</span>(<span class="hljs-params">collection, callback</span>) </span>{
      <span class="hljs-keyword">var</span> iterable = collection,
          length = collection ? collection.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">if</span> (support.unindexedChars &amp;&amp; isString(iterable)) {
          iterable = iterable.split(<span class="hljs-string">''</span>);
        }
        <span class="hljs-keyword">while</span> (length--) {
          <span class="hljs-keyword">if</span> (callback(iterable[length], length, collection) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseForOwnRight(collection, callback);
      }
      <span class="hljs-keyword">return</span> collection;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseFlatten</span>(<span class="hljs-params">array, isShallow, isStrict, fromIndex</span>) </span>{
      <span class="hljs-keyword">var</span> index = (fromIndex || <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>,
          result = [];

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> value = array[index];

        <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.length == <span class="hljs-string">'number'</span>
            &amp;&amp; (isArray(value) || isArguments(value))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>recursively flatten arrays (susceptible to call stack limits)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          <span class="hljs-keyword">var</span> valIndex = -<span class="hljs-number">1</span>,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          <span class="hljs-keyword">while</span> (++valIndex &lt; valLength) {
            result[resIndex++] = value[valIndex];
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isStrict) {
          result.push(value);
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {Object} Returns `object`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseForOwn</span>(<span class="hljs-params">object, callback</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          props = keys(object),
          length = props.length;

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> key = props[index];
        <span class="hljs-keyword">if</span> (callback(object[key], key, object) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {Object} Returns `object`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseForOwnRight</span>(<span class="hljs-params">object, callback</span>) </span>{
      <span class="hljs-keyword">var</span> props = keys(object),
          length = props.length;

      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">var</span> key = props[length];
        <span class="hljs-keyword">if</span> (callback(object[key], key, object) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseIsEqual</span>(<span class="hljs-params">a, b, callback, isWhere, stackA, stackB</span>) </span>{
      <span class="hljs-keyword">if</span> (callback) {
        <span class="hljs-keyword">var</span> result = callback(a, b);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result != <span class="hljs-string">'undefined'</span>) {
          <span class="hljs-keyword">return</span> !!result;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>exit early for identical values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (a === b) {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>treat <code>+0</code> vs. <code>-0</code> as not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> || (<span class="hljs-number">1</span> / a == <span class="hljs-number">1</span> / b);
      }
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> a,
          otherType = <span class="hljs-keyword">typeof</span> b;</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>exit early for unlike primitive values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (a === a &amp;&amp; (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span> ||
          (type != <span class="hljs-string">'function'</span> &amp;&amp; type != <span class="hljs-string">'object'</span> &amp;&amp; otherType != <span class="hljs-string">'function'</span> &amp;&amp; otherType != <span class="hljs-string">'object'</span>))) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>compare [[Class]] names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> className = toString.call(a),
          otherClass = toString.call(b);

      <span class="hljs-keyword">if</span> (className == argsClass) {
        className = objectClass;
      }
      <span class="hljs-keyword">if</span> (otherClass == argsClass) {
        otherClass = objectClass;
      }
      <span class="hljs-keyword">if</span> (className != otherClass) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">switch</span> (className) {
        <span class="hljs-keyword">case</span> boolClass:
        <span class="hljs-keyword">case</span> dateClass:</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>coerce dates and booleans to numbers, dates to milliseconds and booleans
to <code>1</code> or <code>0</code> treating invalid dates coerced to <code>NaN</code> as not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> +a == +b;

        <span class="hljs-keyword">case</span> numberClass:</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>treat <code>NaN</code> vs. <code>NaN</code> as equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> (a != +a)
            ? b != +b</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>but treat <code>-0</code> vs. <code>+0</code> as not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            : (a == <span class="hljs-number">0</span> ? (<span class="hljs-number">1</span> / a == <span class="hljs-number">1</span> / b) : a == +b);

        <span class="hljs-keyword">case</span> regexpClass:
        <span class="hljs-keyword">case</span> stringClass:</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>coerce regexes to strings (<a href="http://es5.github.io/#x15.10.6.4">http://es5.github.io/#x15.10.6.4</a>)
treat string primitives and their corresponding object instances as equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> a == <span class="hljs-built_in">String</span>(b);
      }
      <span class="hljs-keyword">var</span> isArr = className == arrayClass;
      <span class="hljs-keyword">if</span> (!isArr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>unwrap any <code>lodash</code> wrapped values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> aWrapped = hasOwnProperty.call(a, <span class="hljs-string">'__wrapped__'</span>),
            bWrapped = hasOwnProperty.call(b, <span class="hljs-string">'__wrapped__'</span>);

        <span class="hljs-keyword">if</span> (aWrapped || bWrapped) {
          <span class="hljs-keyword">return</span> baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>exit for functions and DOM nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (className != objectClass || (!support.nodeClass &amp;&amp; (isNode(a) || isNode(b)))) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>in older versions of Opera, <code>arguments</code> objects have <code>Array</code> constructors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> ctorA = !support.argsObject &amp;&amp; isArguments(a) ? <span class="hljs-built_in">Object</span> : a.constructor,
            ctorB = !support.argsObject &amp;&amp; isArguments(b) ? <span class="hljs-built_in">Object</span> : b.constructor;</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>non <code>Object</code> object instances with different constructors are not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (ctorA != ctorB &amp;&amp;
              !(hasOwnProperty.call(a, <span class="hljs-string">'constructor'</span>) &amp;&amp; hasOwnProperty.call(b, <span class="hljs-string">'constructor'</span>)) &amp;&amp;
              !(isFunction(ctorA) &amp;&amp; ctorA <span class="hljs-keyword">instanceof</span> ctorA &amp;&amp; isFunction(ctorB) &amp;&amp; ctorB <span class="hljs-keyword">instanceof</span> ctorB) &amp;&amp;
              (<span class="hljs-string">'constructor'</span> <span class="hljs-keyword">in</span> a &amp;&amp; <span class="hljs-string">'constructor'</span> <span class="hljs-keyword">in</span> b)
            ) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>assume cyclic structures are equal
the algorithm for detecting cyclic structures is adapted from ES 5.1
section 15.12.3, abstract operation <code>JO</code> (<a href="http://es5.github.io/#x15.12.3">http://es5.github.io/#x15.12.3</a>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> initedStack = !stackA;
      stackA || (stackA = []);
      stackB || (stackB = []);

      <span class="hljs-keyword">var</span> length = stackA.length;
      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">if</span> (stackA[length] == a) {
          <span class="hljs-keyword">return</span> stackB[length] == b;
        }
      }
      <span class="hljs-keyword">var</span> size = <span class="hljs-number">0</span>;
      result = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>add <code>a</code> and <code>b</code> to the stack of traversed objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      stackA.push(a);
      stackB.push(b);</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>recursively compare objects and arrays (susceptible to call stack limits)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isArr) {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>compare lengths to determine if a deep comparison is necessary</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        length = a.length;
        size = b.length;
        result = size == length;

        <span class="hljs-keyword">if</span> (result || isWhere) {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>deep compare the contents, ignoring non-numeric properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">while</span> (size--) {
            <span class="hljs-keyword">var</span> index = length,
                value = b[size];

            <span class="hljs-keyword">if</span> (isWhere) {
              <span class="hljs-keyword">while</span> (index--) {
                <span class="hljs-keyword">if</span> ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  <span class="hljs-keyword">break</span>;
                }
              }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              <span class="hljs-keyword">break</span>;
            }
          }
        }
      }
      <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>deep compare objects using <code>forIn</code>, instead of <code>forOwn</code>, to avoid <code>Object.keys</code>
which, in this case, is more costly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        baseForIn(b, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, b</span>) </span>{
          <span class="hljs-keyword">if</span> (hasOwnProperty.call(b, key)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>count the number of properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            size++;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>deep compare each property value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> (result = hasOwnProperty.call(a, key) &amp;&amp; baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        <span class="hljs-keyword">if</span> (result &amp;&amp; !isWhere) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>ensure both objects have the same number of properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          baseForIn(a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, a</span>) </span>{
            <span class="hljs-keyword">if</span> (hasOwnProperty.call(a, key)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p><code>size</code> will be <code>-1</code> if <code>a</code> has more properties than <code>b</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> (result = --size &gt; -<span class="hljs-number">1</span>);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseMerge</span>(<span class="hljs-params">object, source, callback, stackA, stackB</span>) </span>{
      (isArray(source) ? baseEach : baseForOwn)(source, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source, key</span>) </span>{
        <span class="hljs-keyword">var</span> found,
            isArr,
            result = source,
            value = object[key];

        <span class="hljs-keyword">if</span> (source &amp;&amp; ((isArr = isArray(source)) || isPlainObject(source))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>avoid merging previously merged cyclic sources</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> stackLength = stackA.length;
          <span class="hljs-keyword">while</span> (stackLength--) {
            <span class="hljs-keyword">if</span> ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              <span class="hljs-keyword">break</span>;
            }
          }
          <span class="hljs-keyword">if</span> (!found) {
            <span class="hljs-keyword">var</span> isShallow;
            <span class="hljs-keyword">if</span> (callback) {
              result = callback(value, source);
              <span class="hljs-keyword">if</span> ((isShallow = <span class="hljs-keyword">typeof</span> result != <span class="hljs-string">'undefined'</span>)) {
                value = result;
              }
            }
            <span class="hljs-keyword">if</span> (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>add <code>source</code> and associated <code>value</code> to the stack of traversed objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            stackA.push(source);
            stackB.push(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>recursively merge objects and arrays (susceptible to call stack limits)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (callback) {
            result = callback(value, source);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result == <span class="hljs-string">'undefined'</span>) {
              result = source;
            }
          }
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result != <span class="hljs-string">'undefined'</span>) {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseRandom</span>(<span class="hljs-params">min, max</span>) </span>{
      <span class="hljs-keyword">return</span> min + floor(nativeRandom() * (max - min + <span class="hljs-number">1</span>));
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseUniq</span>(<span class="hljs-params">array, isSorted, callback</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!length) {
        <span class="hljs-keyword">return</span> [];
      }
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          indexOf = getIndexOf(),
          prereq = !isSorted &amp;&amp; indexOf === baseIndexOf,
          isLarge = prereq &amp;&amp; createCache &amp;&amp; length &gt;= <span class="hljs-number">200</span>,
          isCommon = prereq &amp;&amp; !isLarge,
          result = [];

      <span class="hljs-keyword">if</span> (isLarge) {
        <span class="hljs-keyword">var</span> seen = createCache();
        indexOf = cacheIndexOf;
      } <span class="hljs-keyword">else</span> {
        seen = (callback &amp;&amp; !isSorted) ? [] : result;
      }
      outer:
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> value = array[index],
            computed = callback ? callback(value, index, array) : value;

        <span class="hljs-keyword">if</span> (isCommon) {
          <span class="hljs-keyword">var</span> seenIndex = seen.length;
          <span class="hljs-keyword">while</span> (seenIndex--) {
            <span class="hljs-keyword">if</span> (seen[seenIndex] === computed) {
              <span class="hljs-keyword">continue</span> outer;
            }
          }
          <span class="hljs-keyword">if</span> (callback) {
            seen.push(computed);
          }
          result.push(value);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isSorted) {
          <span class="hljs-keyword">if</span> (!index || seen !== computed) {
            seen = computed;
            result.push(value);
          }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indexOf(seen, computed) &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">if</span> (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} partialArg An array of arguments to prepend to those provided.
     * @param {Array} partialHolders An array of `partialArgs` placeholder indexes.
     * @param {Array|Object} args The provided arguments.
     * @returns {Array} Returns a new array of composed arguments.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">composeArgs</span>(<span class="hljs-params">partialArgs, partialHolders, args</span>) </span>{
      <span class="hljs-keyword">var</span> holdersLength = partialHolders.length,
          argsIndex = -<span class="hljs-number">1</span>,
          argsLength = nativeMax(args.length - holdersLength, <span class="hljs-number">0</span>),
          leftIndex = -<span class="hljs-number">1</span>,
          leftLength = partialArgs.length,
          result = <span class="hljs-built_in">Array</span>(argsLength + leftLength);

      <span class="hljs-keyword">while</span> (++leftIndex &lt; leftLength) {
        result[leftIndex] = partialArgs[leftIndex];
      }
      <span class="hljs-keyword">while</span> (++argsIndex &lt; holdersLength) {
        result[partialHolders[argsIndex]] = args[argsIndex];
      }
      <span class="hljs-keyword">while</span> (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} partialRightArg An array of arguments to append to those provided.
     * @param {Array} partialHolders An array of `partialRightArgs` placeholder indexes.
     * @param {Array|Object} args The provided arguments.
     * @returns {Array} Returns a new array of composed arguments.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">composeArgsRight</span>(<span class="hljs-params">partialRightArgs, partialRightHolders, args</span>) </span>{
      <span class="hljs-keyword">var</span> holdersIndex = -<span class="hljs-number">1</span>,
          holdersLength = partialRightHolders.length,
          argsIndex = -<span class="hljs-number">1</span>,
          argsLength = nativeMax(args.length - holdersLength, <span class="hljs-number">0</span>),
          rightIndex = -<span class="hljs-number">1</span>,
          rightLength = partialRightArgs.length,
          result = <span class="hljs-built_in">Array</span>(argsLength + rightLength);

      <span class="hljs-keyword">while</span> (++argsIndex &lt; argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      <span class="hljs-keyword">var</span> pad = argsIndex;
      <span class="hljs-keyword">while</span> (++rightIndex &lt; rightLength) {
        result[pad + rightIndex] = partialRightArgs[rightIndex];
      }
      <span class="hljs-keyword">while</span> (++holdersIndex &lt; holdersLength) {
        result[pad + partialRightHolders[holdersIndex]] = args[argsIndex++];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates a function that aggregates a collection, creating an object or
     * array composed from the results of running each element of the collection
     * through a callback. The given setter function sets the keys and values
     * of the composed object or array.
     *
     * @private
     * @param {Function} setter The setter function.
     * @param {boolean} [retArray=false] A flag to indicate that the aggregator
     *  function should return an array.
     * @returns {Function} Returns the new aggregator function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAggregator</span>(<span class="hljs-params">setter, retArray</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
        <span class="hljs-keyword">var</span> result = retArray ? [[], []] : {};

        callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);
        <span class="hljs-keyword">if</span> (isArray(collection)) {
          <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
              length = collection.length;

          <span class="hljs-keyword">while</span> (++index &lt; length) {
            <span class="hljs-keyword">var</span> value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } <span class="hljs-keyword">else</span> {
          baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, collection</span>) </span>{
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        <span class="hljs-keyword">return</span> result;
      };
    }

    <span class="hljs-comment">/**
     * Creates a cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [array=[]] The array to search.
     * @returns {Object} Returns the cache object.
     */</span>
    <span class="hljs-keyword">var</span> createCache = <span class="hljs-built_in">Set</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>,
          length = array ? array.length : <span class="hljs-number">0</span>;

      cache.push = cache.add;
      <span class="hljs-keyword">while</span> (length--) {
        cache.push(array[length]);
      }
      <span class="hljs-keyword">return</span> cache;
    };

    <span class="hljs-comment">/**
     * Creates the pad required for `string` based on the given padding length.
     * The `chars` string may be truncated if the number of padding characters
     * exceeds the padding length.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPad</span>(<span class="hljs-params">string, length, chars</span>) </span>{
      <span class="hljs-keyword">var</span> strLength = string.length;
      length = +length || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (strLength &gt;= length) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      <span class="hljs-keyword">var</span> padLength = length - strLength;
      chars = chars == <span class="hljs-literal">null</span> ? <span class="hljs-string">' '</span> : <span class="hljs-built_in">String</span>(chars);
      <span class="hljs-keyword">return</span> repeat(chars, ceil(padLength / chars.length)).slice(<span class="hljs-number">0</span>, padLength);
    }

    <span class="hljs-comment">/**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1  - `_.bind`
     *  2  - `_.bindKey`
     *  4  - `_.curry`
     *  8  - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {number} [arity] The arity of `func`.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {Array} [partialHolders] An array of `partialArgs` placeholder indexes.
     * @param {Array} [partialRightHolders] An array of `partialRightArgs` placeholder indexes.
     * @returns {Function} Returns the new function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWrapper</span>(<span class="hljs-params">func, bitmask, arity, thisArg, partialArgs, partialRightArgs, partialHolders, partialRightHolders</span>) </span>{
      <span class="hljs-keyword">var</span> isBind = bitmask &amp; BIND_FLAG,
          isBindKey = bitmask &amp; BIND_KEY_FLAG,
          isPartial = bitmask &amp; PARTIAL_FLAG,
          isPartialRight = bitmask &amp; PARTIAL_RIGHT_FLAG;

      <span class="hljs-keyword">if</span> (!isBindKey &amp;&amp; !isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">if</span> (isPartial &amp;&amp; !partialArgs.length) {
        bitmask &amp;= ~PARTIAL_FLAG;
        isPartial = partialArgs = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (isPartialRight &amp;&amp; !partialRightArgs.length) {
        bitmask &amp;= ~PARTIAL_RIGHT_FLAG;
        isPartialRight = partialRightArgs = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">var</span> data = !isBindKey &amp;&amp; func[expando];
      <span class="hljs-keyword">if</span> (data &amp;&amp; data !== <span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>shallow clone <code>data</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        data = slice(data);</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>clone partial left arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">4</span>]) {
          data[<span class="hljs-number">4</span>] = slice(data[<span class="hljs-number">4</span>]);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>clone partial right arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">5</span>]) {
          data[<span class="hljs-number">5</span>] = slice(data[<span class="hljs-number">5</span>]);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>set arity if provided</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arity == <span class="hljs-string">'number'</span>) {
          data[<span class="hljs-number">2</span>] = arity;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>set <code>thisArg</code> if not previously bound</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> bound = data[<span class="hljs-number">1</span>] &amp; BIND_FLAG;
        <span class="hljs-keyword">if</span> (isBind &amp;&amp; !bound) {
          data[<span class="hljs-number">3</span>] = thisArg;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>set if currying a bound function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!isBind &amp;&amp; bound) {
          bitmask |= CURRY_BOUND_FLAG;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>append partial left arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isPartial) {
          <span class="hljs-keyword">if</span> (data[<span class="hljs-number">4</span>]) {
            push.apply(data[<span class="hljs-number">4</span>], partialArgs);
          } <span class="hljs-keyword">else</span> {
            data[<span class="hljs-number">4</span>] = partialArgs;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>prepend partial right arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (isPartialRight) {
          <span class="hljs-keyword">if</span> (data[<span class="hljs-number">5</span>]) {
            unshift.apply(data[<span class="hljs-number">5</span>], partialRightArgs);
          } <span class="hljs-keyword">else</span> {
            data[<span class="hljs-number">5</span>] = partialRightArgs;
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>merge flags</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        data[<span class="hljs-number">1</span>] |= bitmask;
        <span class="hljs-keyword">return</span> createWrapper.apply(<span class="hljs-literal">null</span>, data);
      }
      <span class="hljs-keyword">if</span> (arity == <span class="hljs-literal">null</span>) {
        arity = isBindKey ? <span class="hljs-number">0</span> : func.length;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arity &lt; <span class="hljs-number">0</span>) {
        arity = <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">if</span> (isPartial) {
        partialHolders = getHolders(partialArgs);
      }
      <span class="hljs-keyword">if</span> (isPartialRight) {
        partialRightHolders = getHolders(partialRightArgs);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>fast path for <code>_.bind</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      data = [func, bitmask, arity, thisArg, partialArgs, partialRightArgs, partialHolders, partialRightHolders];
      <span class="hljs-keyword">return</span> (bitmask == BIND_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG))
        ? baseBind(data)
        : baseCreateWrapper(data);
    }

    <span class="hljs-comment">/**
     * Creates compiled iteration functions.
     *
     * @private
     * @param {Object} [options] The compile options object.
     * @param {string} [options.args] A comma separated string of iteration function arguments.
     * @param {string} [options.init] The string representation of the initial `result` value.
     * @param {string} [options.loop] Code to execute in the object loop.
     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
     * @returns {Function} Returns the compiled function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterator</span>(<span class="hljs-params">options</span>) </span>{
      options.shadowedProps = shadowedProps;
      options.support = support;</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>create the function factory</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> factory = <span class="hljs-built_in">Function</span>(
          <span class="hljs-string">'errorClass, errorProto, hasOwnProperty, isArguments, isObject, objectProto, '</span> +
          <span class="hljs-string">'nonEnumProps, stringClass, stringProto, toString'</span>,
        <span class="hljs-string">'return function('</span> + options.args + <span class="hljs-string">') {\n'</span> + iteratorTemplate(options) + <span class="hljs-string">'\n}'</span>
      );</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>return the compiled function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> factory(
        errorClass, errorProto, hasOwnProperty, isArguments, isObject, objectProto,
        nonEnumProps, stringClass, stringProto, toString
      );
    }

    <span class="hljs-comment">/**
     * Finds the indexes of all placeholder elements in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns a new array of placeholder indexes.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHolders</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = array.length,
          result = [];

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">if</span> (array[index] === lodash) {
          result.push(index);
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIndexOf</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNative</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'function'</span> &amp;&amp; reNative.test(fnToString.call(value));
    }

    <span class="hljs-comment">/**
     * Sets wrapper metadata on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */</span>
    <span class="hljs-keyword">var</span> setData = !defineProperty ? noop : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, value</span>) </span>{
      descriptor.value = value;
      defineProperty(func, expando, descriptor);
    };

    <span class="hljs-comment">/**
     * A fallback implementation of `isPlainObject` which checks if `value` is
     * an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and
     * that there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shimIsPlainObject</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> ctor,
          result;</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>avoid non Object objects, <code>arguments</code> objects, and DOM elements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!(value &amp;&amp; toString.call(value) == objectClass) ||
          (!hasOwnProperty.call(value, <span class="hljs-string">'constructor'</span>) &amp;&amp;
            (ctor = value.constructor, isFunction(ctor) &amp;&amp; !(ctor <span class="hljs-keyword">instanceof</span> ctor))) ||
          (!support.argsClass &amp;&amp; isArguments(value)) ||
          (!support.nodeClass &amp;&amp; isNode(value))) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>IE &lt; 9 iterates inherited properties before own properties. If the first
iterated property is an object’s own property then there are no inherited
enumerable properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (support.ownLast) {
        baseForIn(value, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
          result = hasOwnProperty.call(object, key);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        });
        <span class="hljs-keyword">return</span> result !== <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>In most environments an object’s own properties are iterated before
its inherited properties. If the last iterated property is an object’s
own property then there are no inherited enumerable properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      baseForIn(value, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
        result = key;
      });
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result == <span class="hljs-string">'undefined'</span> || hasOwnProperty.call(value, result);
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // =&gt; true
     *
     * _.isArguments([1, 2, 3]);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArguments</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.length == <span class="hljs-string">'number'</span> &amp;&amp;
        toString.call(value) == argsClass || <span class="hljs-literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>fallback for environments that can’t detect <code>arguments</code> objects by [[Class]]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!support.argsClass) {
      isArguments = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.length == <span class="hljs-string">'number'</span> &amp;&amp;
          hasOwnProperty.call(value, <span class="hljs-string">'callee'</span>) &amp;&amp; !propertyIsEnumerable.call(value, <span class="hljs-string">'callee'</span>) || <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-comment">/**
     * The base implementation of `_.forIn` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {Object} Returns `object`.
     */</span>
    <span class="hljs-keyword">var</span> baseForIn = createIterator({
      <span class="hljs-string">'args'</span>: <span class="hljs-string">'object, callback'</span>,
      <span class="hljs-string">'init'</span>: <span class="hljs-string">'object'</span>,
      <span class="hljs-string">'loop'</span>: <span class="hljs-string">'if (callback(object[key], key, object) === false) {\n    return result;\n  }'</span>,
      <span class="hljs-string">'useHas'</span>: <span class="hljs-literal">false</span>
    });

    <span class="hljs-comment">/**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */</span>
    <span class="hljs-keyword">var</span> shimKeys = createIterator({
      <span class="hljs-string">'args'</span>: <span class="hljs-string">'object'</span>,
      <span class="hljs-string">'init'</span>: <span class="hljs-string">'[]'</span>,
      <span class="hljs-string">'loop'</span>: <span class="hljs-string">'result.push(key)'</span>,
      <span class="hljs-string">'useHas'</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // =&gt; [1, 2, 3]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compact</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>,
          resIndex = <span class="hljs-number">0</span>,
          result = [];

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> value = array[index];
        <span class="hljs-keyword">if</span> (value) {
          result[resIndex++] = value;
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [5, 2, 10]);
     * // =&gt; [1, 3]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">difference</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">return</span> baseDifference(array, baseFlatten(<span class="hljs-built_in">arguments</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>));
    }

    <span class="hljs-comment">/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3], 1);
     * // =&gt; [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // =&gt; [3]
     *
     * _.drop([1, 2, 3], 5);
     * // =&gt; []
     *
     * _.drop([1, 2, 3], 0);
     * // =&gt; [1, 2, 3]
     */</span>
    <span class="hljs-keyword">var</span> drop = rest;

    <span class="hljs-comment">/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3], 1);
     * // =&gt; [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // =&gt; [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // =&gt; []
     *
     * _.dropRight([1, 2, 3], 0);
     * // =&gt; [1, 2, 3]
     */</span>
    <span class="hljs-keyword">var</span> dropRight = initial;

    <span class="hljs-comment">/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements will be dropped until the predicate returns falsey. The predicate
     * is bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per element.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(num) {
     *   return num &gt; 1;
     * });
     * // =&gt; [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'employer': 'slate' },
     *   { 'name': 'fred',    'employer': 'slate', 'blocked': true },
     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.dropRightWhile(characters, 'blocked'), 'name');
     * // =&gt; ['barney']
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.dropRightWhile(characters, { 'employer': 'na' }), 'name');
     * // =&gt; ['barney', 'fred']
     */</span>
    <span class="hljs-keyword">var</span> dropRightWhile = initial;

    <span class="hljs-comment">/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements will be dropped until the predicate returns falsey. The predicate
     * is bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per element.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(num) {
     *   return num &lt; 3;
     * });
     * // =&gt; [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'employer': 'slate', 'blocked': true },
     *   { 'name': 'fred',    'employer': 'slate' },
     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.dropWhile(characters, 'blocked'), 'name');
     * // =&gt; ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.dropWhile(characters, { 'employer': 'slate' }), 'name');
     * // =&gt; ['pebbles']
     */</span>
    <span class="hljs-keyword">var</span> dropWhile = rest;

    <span class="hljs-comment">/**
     * This method is like `_.find` except that it returns the index of the first
     * element the predicate returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age &lt; 20;
     * });
     * // =&gt; 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // =&gt; 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // =&gt; 1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findIndex</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">if</span> (predicate(array[index], index, array)) {
          <span class="hljs-keyword">return</span> index;
        }
      }
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age &gt; 30;
     * });
     * // =&gt; 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // =&gt; 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // =&gt; 2
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLastIndex</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">if</span> (predicate(array[length], length, array)) {
          <span class="hljs-keyword">return</span> length;
        }
      }
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Arrays
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // =&gt; 1
     *
     * _.first([]);
     * // =&gt; undefined
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'number'</span> &amp;&amp; predicate != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = array ? array.length : <span class="hljs-number">0</span>,
            n = <span class="hljs-number">0</span>;

        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        <span class="hljs-keyword">while</span> (++index &lt; length &amp;&amp; predicate(array[index], index, array)) {
          n++;
        }
      } <span class="hljs-keyword">else</span> {
        n = predicate;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span> || thisArg) {
          <span class="hljs-keyword">return</span> array ? array[<span class="hljs-number">0</span>] : <span class="hljs-literal">undefined</span>;
        }
      }
      <span class="hljs-keyword">return</span> slice(array, <span class="hljs-number">0</span>, n &gt; <span class="hljs-number">0</span> ? n : <span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">/**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truthy, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback] The function called per iteration.
     *  If a property name or object is provided it will be used to create a "_.pluck"
     *  or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // =&gt; [1, 2, 3, 4];
     *
     * // using `isShallow`
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // =&gt; [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // =&gt; ['hoppy', 'baby puss', 'dino']
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">array, isShallow, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!length) {
        <span class="hljs-keyword">return</span> [];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>juggle arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> isShallow;
      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">'boolean'</span> &amp;&amp; isShallow != <span class="hljs-literal">null</span>) {
        thisArg = callback;
        callback = isShallow;
        isShallow = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; thisArg &amp;&amp; thisArg[callback] === array) {
          callback = <span class="hljs-literal">null</span>;
        }
      }
      <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) {
        array = map(array, callback, thisArg);
      }
      <span class="hljs-keyword">return</span> baseFlatten(array, isShallow);
    }

    <span class="hljs-comment">/**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // =&gt; 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // =&gt; 4
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // =&gt; 2
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span>(<span class="hljs-params">array, value, fromIndex</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fromIndex == <span class="hljs-string">'number'</span>) {
        fromIndex = fromIndex &lt; <span class="hljs-number">0</span> ? nativeMax(<span class="hljs-number">0</span>, length + fromIndex) : (fromIndex || <span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fromIndex) {
        <span class="hljs-keyword">var</span> index = sortedIndex(array, value);
        <span class="hljs-keyword">return</span> (length &amp;&amp; array[index] === value) ? index : -<span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">return</span> baseIndexOf(array, value, fromIndex);
    }

    <span class="hljs-comment">/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // =&gt; [1, 2]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initial</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'number'</span> &amp;&amp; predicate != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> index = length,
            n = <span class="hljs-number">0</span>;

        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        <span class="hljs-keyword">while</span> (index-- &amp;&amp; predicate(array[index], index, array)) {
          n++;
        }
      } <span class="hljs-keyword">else</span> {
        n = (predicate == <span class="hljs-literal">null</span> || thisArg) ? <span class="hljs-number">1</span> : predicate;
      }
      n = length - n;
      <span class="hljs-keyword">return</span> slice(array, <span class="hljs-number">0</span>, n &gt; <span class="hljs-number">0</span> ? n : <span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">/**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // =&gt; [1, 2]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> args = [],
          argsIndex = -<span class="hljs-number">1</span>,
          argsLength = <span class="hljs-built_in">arguments</span>.length,
          caches = [],
          indexOf = getIndexOf(),
          prereq = createCache &amp;&amp; indexOf === baseIndexOf,
          seen = [];

      <span class="hljs-keyword">while</span> (++argsIndex &lt; argsLength) {
        <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">arguments</span>[argsIndex];
        <span class="hljs-keyword">if</span> (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(prereq &amp;&amp; value.length &gt;= <span class="hljs-number">120</span> &amp;&amp;
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      <span class="hljs-keyword">var</span> array = args[<span class="hljs-number">0</span>],
          index = -<span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>,
          result = [];

      outer:
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> cache = caches[<span class="hljs-number">0</span>];
        value = array[index];

        <span class="hljs-keyword">if</span> ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) &lt; <span class="hljs-number">0</span>) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          <span class="hljs-keyword">while</span> (--argsIndex) {
            cache = caches[argsIndex];
            <span class="hljs-keyword">if</span> ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) &lt; <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">continue</span> outer;
            }
          }
          result.push(value);
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // =&gt; 3
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">last</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'number'</span> &amp;&amp; predicate != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> index = length,
            n = <span class="hljs-number">0</span>;

        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        <span class="hljs-keyword">while</span> (index-- &amp;&amp; predicate(array[index], index, array)) {
          n++;
        }
      } <span class="hljs-keyword">else</span> {
        n = predicate;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span> || thisArg) {
          <span class="hljs-keyword">return</span> array ? array[length - <span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;
        }
      }
      n = length - n;
      <span class="hljs-keyword">return</span> slice(array,  n &gt; <span class="hljs-number">0</span> ? n : <span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">/**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // =&gt; 4
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // =&gt; 1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastIndexOf</span>(<span class="hljs-params">array, value, fromIndex</span>) </span>{
      <span class="hljs-keyword">var</span> index = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fromIndex == <span class="hljs-string">'number'</span>) {
        index = (fromIndex &lt; <span class="hljs-number">0</span> ? nativeMax(<span class="hljs-number">0</span>, index + fromIndex) : nativeMin(fromIndex, index - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">while</span> (index--) {
        <span class="hljs-keyword">if</span> (array[index] === value) {
          <span class="hljs-keyword">return</span> index;
        }
      }
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">/**
     * Removes all provided values from `array` using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // =&gt; [1, 1]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pull</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">var</span> argsIndex = <span class="hljs-number">0</span>,
          argsLength = <span class="hljs-built_in">arguments</span>.length,
          length = array ? array.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">while</span> (++argsIndex &lt; argsLength) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            value = <span class="hljs-built_in">arguments</span>[argsIndex];

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">if</span> (array[index] === value) {
            splice.call(array, index--, <span class="hljs-number">1</span>);
            length--;
          }
        }
      }
      <span class="hljs-keyword">return</span> array;
    }

    <span class="hljs-comment">/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // =&gt; [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // =&gt; [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // =&gt; [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // =&gt; [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // =&gt; [1, 1, 1]
     *
     * _.range(0);
     * // =&gt; []
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span>(<span class="hljs-params">start, end, step</span>) </span>{
      start = +start || <span class="hljs-number">0</span>;
      step = <span class="hljs-keyword">typeof</span> step == <span class="hljs-string">'number'</span> ? step : (+step || <span class="hljs-number">1</span>);

      <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) {
        end = start;
        start = <span class="hljs-number">0</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>use <code>Array(length)</code> so engines like Chakra and V8 avoid slower modes
<a href="http://youtu.be/XAqIpGU8ZZk#t=17m25s">http://youtu.be/XAqIpGU8ZZk#t=17m25s</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = nativeMax(<span class="hljs-number">0</span>, ceil((end - start) / (step || <span class="hljs-number">1</span>))),
          result = <span class="hljs-built_in">Array</span>(length);

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        result[index] = start;
        start += step;
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Removes all elements from an array that the predicate returns truthy for
     * and returns an array of removed elements. The predicate is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // =&gt; [1, 3, 5]
     *
     * console.log(evens);
     * // =&gt; [2, 4, 6]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>,
          result = [];

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> value = array[index];
        <span class="hljs-keyword">if</span> (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, <span class="hljs-number">1</span>);
          length--;
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // =&gt; [2, 3]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rest</span>(<span class="hljs-params">array, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'number'</span> &amp;&amp; predicate != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = array ? array.length : <span class="hljs-number">0</span>,
            n = <span class="hljs-number">0</span>;

        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        <span class="hljs-keyword">while</span> (++index &lt; length &amp;&amp; predicate(array[index], index, array)) {
          n++;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (predicate == <span class="hljs-literal">null</span> || thisArg) {
        n = <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        n = predicate &gt; <span class="hljs-number">0</span> ? predicate : <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">return</span> slice(array, n);
    }

    <span class="hljs-comment">/**
     * Slices `array` from the `start` index up to, but not including, the `end` index.
     *
     * Note: This function is used instead of `Array#slice` to support node lists
     * in IE &lt; 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start index.
     * @param {number} [end=array.length] The end index.
     * @returns {Array} Returns the new array.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slice</span>(<span class="hljs-params">array, start, end</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = array ? array.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> start == <span class="hljs-string">'undefined'</span>) {
        start = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>) {
        start = nativeMax(length + start, <span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start &gt; length) {
        start = length;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> end == <span class="hljs-string">'undefined'</span>) {
        end = length;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) {
        end = nativeMax(length + end, <span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end &gt; length) {
        end = length;
      }
      length = end - start || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Array</span>(length);
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        result[index] = array[start + index];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // =&gt; 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * // using `callback`
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // =&gt; 2
     *
     * // using `callback` with `thisArg`
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // =&gt; 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // =&gt; 2
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortedIndex</span>(<span class="hljs-params">array, value, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> low = <span class="hljs-number">0</span>,
          high = array ? array.length : low;</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>explicitly reference <code>identity</code> for better inlining in Firefox</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      callback = callback ? lodash.createCallback(callback, thisArg, <span class="hljs-number">1</span>) : identity;
      value = callback(value);

      <span class="hljs-keyword">while</span> (low &lt; high) {
        <span class="hljs-keyword">var</span> mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;
        (callback(array[mid]) &lt; value)
          ? (low = mid + <span class="hljs-number">1</span>)
          : (high = mid);
      }
      <span class="hljs-keyword">return</span> low;
    }

    <span class="hljs-comment">/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3], 1);
     * // =&gt; [1]
     *
     * _.take([1, 2, 3], 2);
     * // =&gt; [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // =&gt; [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // =&gt; []
     */</span>
    <span class="hljs-keyword">var</span> take = first;

    <span class="hljs-comment">/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3], 1);
     * // =&gt; [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // =&gt; [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // =&gt; [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // =&gt; []
     */</span>
    <span class="hljs-keyword">var</span> takeRight = last;

    <span class="hljs-comment">/**
     * Creates a slice of `array` with elements taken from the end. Elements will
     * be taken until the predicate returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per element.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(num) {
     *   return num &gt; 1;
     * });
     * // =&gt; [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'employer': 'slate' },
     *   { 'name': 'fred',    'employer': 'slate', 'blocked': true },
     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.takeRightWhile(characters, 'blocked'), 'name');
     * // =&gt; ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.takeRightWhile(characters, { 'employer': 'na' }), 'name');
     * // =&gt; ['pebbles']
     */</span>
    <span class="hljs-keyword">var</span> takeRightWhile = last;

    <span class="hljs-comment">/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * will be taken until the predicate returns falsey. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per element.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(num) {
     *   return num &lt; 3;
     * });
     * // =&gt; [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'employer': 'slate', 'blocked': true },
     *   { 'name': 'fred',    'employer': 'slate' },
     *   { 'name': 'pebbles', 'employer': 'na',    'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.takeWhile(characters, 'blocked'), 'name');
     * // =&gt; ['barney']
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.takeWhile(characters, { 'employer': 'slate' }), 'name');
     * // =&gt; ['barney', 'fred']
     */</span>
    <span class="hljs-keyword">var</span> takeWhile = first;

    <span class="hljs-comment">/**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // =&gt; [1, 2, 3, 5, 4]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">union</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> baseUniq(baseFlatten(<span class="hljs-built_in">arguments</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));
    }

    <span class="hljs-comment">/**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback] The function called per iteration.
     *  If a property name or object is provided it will be used to create a "_.pluck"
     *  or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // =&gt; [1, 2, 3]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2, 2, 3], true);
     * // =&gt; [1, 2, 3]
     *
     * // using `callback`
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // =&gt; ['A', 'b', 'C']
     *
     * // using `callback` with `thisArg`
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // =&gt; [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // =&gt; [{ 'x': 1 }, { 'x': 2 }]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniq</span>(<span class="hljs-params">array, isSorted, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> length = array ? array.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!length) {
        <span class="hljs-keyword">return</span> [];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>juggle arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> isSorted;
      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">'boolean'</span> &amp;&amp; isSorted != <span class="hljs-literal">null</span>) {
        thisArg = callback;
        callback = isSorted;
        isSorted = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; thisArg &amp;&amp; thisArg[callback] === array) {
          callback = <span class="hljs-literal">null</span>;
        }
      }
      <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) {
        callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);
      }
      <span class="hljs-keyword">return</span> baseUniq(array, isSorted, callback);
    }

    <span class="hljs-comment">/**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // =&gt; [2, 3, 4]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">without</span>(<span class="hljs-params">array</span>) </span>{
      <span class="hljs-keyword">return</span> baseDifference(array, slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
    }

    <span class="hljs-comment">/**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See [Wikipedia](http://en.wikipedia.org/wiki/Symmetric_difference) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // =&gt; [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // =&gt; [1, 4, 5]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xor</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = <span class="hljs-built_in">arguments</span>.length;

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> array = <span class="hljs-built_in">arguments</span>[index];
        <span class="hljs-keyword">if</span> (isArray(array) || isArguments(array)) {
          <span class="hljs-keyword">var</span> result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      <span class="hljs-keyword">return</span> result ? baseUniq(result) : [];
    }

    <span class="hljs-comment">/**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on. If a zipped value is provided its corresponding
     * unzipped value will be returned.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] The arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // =&gt; [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip([['fred', 30, true], ['barney', 40, false]]);
     * // =&gt; [['fred', 'barney'], [30, 40], [true, false]]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zip</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> array = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-built_in">arguments</span> : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>],
          index = -<span class="hljs-number">1</span>,
          length = array ? max(pluck(array, <span class="hljs-string">'length'</span>)) : <span class="hljs-number">0</span>,
          result = <span class="hljs-built_in">Array</span>(length &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : length);

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        result[index] = pluck(array, index);
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // =&gt; { 'fred': 30, 'barney': 40 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zipObject</span>(<span class="hljs-params">keys, values</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = keys ? keys.length : <span class="hljs-number">0</span>,
          result = {};

      <span class="hljs-keyword">if</span> (!values &amp;&amp; length &amp;&amp; !isArray(keys[<span class="hljs-number">0</span>])) {
        values = [];
      }
      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> key = keys[index];
        <span class="hljs-keyword">if</span> (values) {
          result[key] = values[index];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key) {
          result[key[<span class="hljs-number">0</span>]] = key[<span class="hljs-number">1</span>];
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // =&gt; 'pebbles is 1'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chain</span>(<span class="hljs-params">value</span>) </span>{
      value = <span class="hljs-keyword">new</span> lodashWrapper(value);
      value.__chain__ = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-comment">/**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // =&gt; [3, 2, 1]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tap</span>(<span class="hljs-params">value, interceptor, thisArg</span>) </span>{
      interceptor.call(thisArg, value);
      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-comment">/**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // =&gt; { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // =&gt; { 'age': 36 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapperChain</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.__chain__ = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">/**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // =&gt; '1,2,3'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapperToString</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(<span class="hljs-keyword">this</span>.__wrapped__);
    }

    <span class="hljs-comment">/**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // =&gt; [1, 2, 3]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapperValueOf</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__wrapped__;
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // =&gt; ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // =&gt; ['fred', 'pebbles']
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">at</span>(<span class="hljs-params">collection, guard</span>) </span>{
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
          index = -<span class="hljs-number">1</span>,
          props = baseFlatten(args, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>),
          length = props.length,
          type = <span class="hljs-keyword">typeof</span> guard;</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; args[<span class="hljs-number">2</span>] &amp;&amp; args[<span class="hljs-number">2</span>][guard] === collection) {
        length = <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">if</span> (support.unindexedChars &amp;&amp; isString(collection)) {
        collection = collection.split(<span class="hljs-string">''</span>);
      }
      <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Array</span>(length);
      <span class="hljs-keyword">while</span>(++index &lt; length) {
        result[index] = collection[props[index]];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the target element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // =&gt; true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // =&gt; false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // =&gt; true
     *
     * _.contains('pebbles', 'eb');
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span>(<span class="hljs-params">collection, target, fromIndex</span>) </span>{
      <span class="hljs-keyword">var</span> length = collection ? collection.length : <span class="hljs-number">0</span>;
      fromIndex = <span class="hljs-keyword">typeof</span> fromIndex == <span class="hljs-string">'number'</span> ? fromIndex : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">if</span> (fromIndex &gt;= length) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> collection == <span class="hljs-string">'string'</span> || !isArray(collection) &amp;&amp; isString(collection)) {
          <span class="hljs-keyword">return</span> nativeContains
            ? nativeContains.call(collection, target, fromIndex)
            : collection.indexOf(target, fromIndex) &gt; -<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">var</span> indexOf = getIndexOf();
        fromIndex = (fromIndex &lt; <span class="hljs-number">0</span> ? nativeMax(<span class="hljs-number">0</span>, length + fromIndex) : fromIndex) || <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> indexOf(collection, target, fromIndex) &gt; -<span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          result = <span class="hljs-literal">false</span>;

      baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">if</span> (++index &gt;= fromIndex) {
          <span class="hljs-keyword">return</span> !(result = value === target);
        }
      });

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // =&gt; { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // =&gt; { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // =&gt; { '3': 2, '5': 1 }
     */</span>
    <span class="hljs-keyword">var</span> countBy = createAggregator(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, value, key</span>) </span>{
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = <span class="hljs-number">1</span>);
    });

    <span class="hljs-comment">/**
     * Checks if the predicate returns truthy for **all** elements of a collection.
     * The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements passed the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // =&gt; false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // =&gt; true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">every</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result = <span class="hljs-literal">true</span>;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">if</span> (!predicate(collection[index], index, collection)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">return</span> (result = !!predicate(value, index, collection));
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Iterates over elements of a collection returning an array of all elements
     * the predicate returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns a new array of elements that passed the predicate check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4], function(num) { return num % 2 == 0; });
     * // =&gt; [2, 4]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // =&gt; [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // =&gt; [{ 'name': 'barney', 'age': 36 }]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result = [];

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> value = collection[index];
          <span class="hljs-keyword">if</span> (predicate(value, index, collection)) {
            result.push(value);
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">if</span> (predicate(value, index, collection)) {
            result.push(value);
          }
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Iterates over elements of a collection, returning the first element that
     * the predicate returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age &lt; 40;
     * });
     * // =&gt; { 'name': 'barney', 'age': 36 }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =&gt;  { 'name': 'pebbles', 'age': 1 }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // =&gt; { 'name': 'fred', 'age': 40, 'blocked': true }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> value = collection[index];
          <span class="hljs-keyword">if</span> (predicate(value, index, collection)) {
            <span class="hljs-keyword">return</span> value;
          }
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> result;
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">if</span> (predicate(value, index, collection)) {
            result = value;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }
        });
        <span class="hljs-keyword">return</span> result;
      }
    }

    <span class="hljs-comment">/**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // =&gt; 3
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLast</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      baseEachRight(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
        <span class="hljs-keyword">if</span> (predicate(value, index, collection)) {
          result = value;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      });
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // =&gt; logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // =&gt; logs each number and returns the object (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">if</span> (callback &amp;&amp; <span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> &amp;&amp; isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">if</span> (callback(collection[index], index, collection) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>));
      }
      <span class="hljs-keyword">return</span> collection;
    }

    <span class="hljs-comment">/**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // =&gt; logs each number from right to left and returns '3,2,1'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachRight</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">if</span> (callback &amp;&amp; <span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> &amp;&amp; isArray(collection)) {
        <span class="hljs-keyword">var</span> length = collection.length;
        <span class="hljs-keyword">while</span> (length--) {
          <span class="hljs-keyword">if</span> (callback(collection[length], length, collection) === <span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseEachRight(collection, baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>));
      }
      <span class="hljs-keyword">return</span> collection;
    }

    <span class="hljs-comment">/**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // =&gt; { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // =&gt; { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // =&gt; { '3': ['one', 'two'], '5': ['three'] }
     */</span>
    <span class="hljs-keyword">var</span> groupBy = createAggregator(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, value, key</span>) </span>{
      <span class="hljs-keyword">if</span> (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } <span class="hljs-keyword">else</span> {
        result[key] = [value];
      }
    });

    <span class="hljs-comment">/**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // =&gt; { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // =&gt; { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return this.fromCharCode(key.code); }, String);
     * // =&gt; { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */</span>
    <span class="hljs-keyword">var</span> indexBy = createAggregator(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, value, key</span>) </span>{
      result[key] = value;
    });

    <span class="hljs-comment">/**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // =&gt; [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // =&gt; [['1', '2', '3'], ['4', '5', '6']]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span>(<span class="hljs-params">collection, methodName</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          isFunc = <span class="hljs-keyword">typeof</span> methodName == <span class="hljs-string">'function'</span>,
          length = collection ? collection.length : <span class="hljs-number">0</span>,
          result = <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> ? length : <span class="hljs-number">0</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span> &amp;&amp; isArray(collection)) {
        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> value = collection[index];
          result[index] = isFunc ? methodName.call(value) : value[methodName]();
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> args = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
          result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // =&gt; [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // =&gt; [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // =&gt; ['barney', 'fred']
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = collection ? collection.length : <span class="hljs-number">0</span>,
          result = <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> ? length : <span class="hljs-number">0</span>);

      callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">while</span> (++index &lt; length) {
          result[index] = callback(collection[index], index, collection);
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, collection</span>) </span>{
          result[++index] = callback(value, key, collection);
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback] The function called per iteration.
     *  If a property name or object is provided it will be used to create a "_.pluck"
     *  or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // =&gt; 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // =&gt; { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // =&gt; { 'name': 'fred', 'age': 40 };
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> computed = -<span class="hljs-literal">Infinity</span>,
          result = computed,
          type = <span class="hljs-keyword">typeof</span> callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; thisArg &amp;&amp; thisArg[callback] === collection) {
        callback = <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">if</span> (callback == <span class="hljs-literal">null</span> &amp;&amp; isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> value = collection[index];
          <span class="hljs-keyword">if</span> (value &gt; result) {
            result = value;
          }
        }
      } <span class="hljs-keyword">else</span> {
        callback = (callback == <span class="hljs-literal">null</span> &amp;&amp; isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);

        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">var</span> current = callback(value, index, collection);
          <span class="hljs-keyword">if</span> (current &gt; computed) {
            computed = current;
            result = value;
          }
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback] The function called per iteration.
     *  If a property name or object is provided it will be used to create a "_.pluck"
     *  or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // =&gt; 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // =&gt; { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // =&gt; { 'name': 'barney', 'age': 36 };
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> computed = <span class="hljs-literal">Infinity</span>,
          result = computed,
          type = <span class="hljs-keyword">typeof</span> callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; thisArg &amp;&amp; thisArg[callback] === collection) {
        callback = <span class="hljs-literal">null</span>;
      }
      <span class="hljs-keyword">if</span> (callback == <span class="hljs-literal">null</span> &amp;&amp; isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> value = collection[index];
          <span class="hljs-keyword">if</span> (value &lt; result) {
            result = value;
          }
        }
      } <span class="hljs-keyword">else</span> {
        callback = (callback == <span class="hljs-literal">null</span> &amp;&amp; isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);

        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">var</span> current = callback(value, index, collection);
          <span class="hljs-keyword">if</span> (current &lt; computed) {
            computed = current;
            result = value;
          }
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements the predicate returns truthy for, while the second of which
     * contains elements the predicate returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(num) { return num % 2; });
     * // =&gt; [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(num) { return this.floor(num) % 2; }, Math);
     * // =&gt; [[1, 3], [2]]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.map(_.partition(characters, { 'age': 1 }), function(array) { return _.pluck(array, 'name'); });
     * // =&gt; [['pebbles'], ['barney', 'fred']]
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.partition(characters, 'blocked'), function(array) { return _.pluck(array, 'name'); });
     * // =&gt; [['fred'], ['barney', 'pebbles']]
     */</span>
    <span class="hljs-keyword">var</span> partition = createAggregator(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, value, key</span>) </span>{
      result[key ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].push(value);
    }, <span class="hljs-literal">true</span>);

    <span class="hljs-comment">/**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // =&gt; ['barney', 'fred']
     */</span>
    <span class="hljs-keyword">var</span> pluck = map;

    <span class="hljs-comment">/**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // =&gt; 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // =&gt; { 'a': 3, 'b': 6, 'c': 9 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">collection, callback, accumulator, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> noaccum = <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span>;

      callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">4</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">if</span> (noaccum &amp;&amp; length) {
          accumulator = collection[++index];
        }
        <span class="hljs-keyword">while</span> (++index &lt; length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          accumulator = noaccum
            ? (noaccum = <span class="hljs-literal">false</span>, value)
            : callback(accumulator, value, index, collection)
        });
      }
      <span class="hljs-keyword">return</span> accumulator;
    }

    <span class="hljs-comment">/**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // =&gt; [4, 5, 2, 3, 0, 1]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduceRight</span>(<span class="hljs-params">collection, callback, accumulator, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> noaccum = <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span>;

      callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">4</span>);
      baseEachRight(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
        accumulator = noaccum
          ? (noaccum = <span class="hljs-literal">false</span>, value)
          : callback(accumulator, value, index, collection);
      });
      <span class="hljs-keyword">return</span> accumulator;
    }

    <span class="hljs-comment">/**
     * The opposite of `_.filter`; this method returns the elements of a collection
     * the predicate does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns a new array of elements that failed the predicate check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4], function(num) { return num % 2 == 0; });
     * // =&gt; [1, 3]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // =&gt; [{ 'name': 'barney', 'age': 36 }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // =&gt; [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">return</span> filter(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
        <span class="hljs-keyword">return</span> !predicate(value, index, collection);
      });
    }

    <span class="hljs-comment">/**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // =&gt; 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // =&gt; [3, 1]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sample</span>(<span class="hljs-params">collection, n, guard</span>) </span>{
      <span class="hljs-keyword">if</span> (collection &amp;&amp; <span class="hljs-keyword">typeof</span> collection.length != <span class="hljs-string">'number'</span>) {
        collection = values(collection);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (support.unindexedChars &amp;&amp; isString(collection)) {
        collection = collection.split(<span class="hljs-string">''</span>);
      }
      <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span> || guard) {
        <span class="hljs-keyword">return</span> collection ? collection[baseRandom(<span class="hljs-number">0</span>, collection.length - <span class="hljs-number">1</span>)] : <span class="hljs-literal">undefined</span>;
      }
      <span class="hljs-keyword">var</span> result = shuffle(collection);
      result.length = nativeMin(nativeMax(<span class="hljs-number">0</span>, n), result.length);
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See [Wikipedia](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // =&gt; [4, 1, 3, 2]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">collection</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          length = collection ? collection.length : <span class="hljs-number">0</span>,
          result = <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> ? length : <span class="hljs-number">0</span>);

      baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">var</span> rand = baseRandom(<span class="hljs-number">0</span>, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });

      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // =&gt; 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // =&gt; 3
     *
     * _.size('pebbles');
     * // =&gt; 7
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">size</span>(<span class="hljs-params">collection</span>) </span>{
      <span class="hljs-keyword">var</span> length = collection ? collection.length : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> ? length : keys(collection).length;
    }

    <span class="hljs-comment">/**
     * Checks if the predicate returns truthy for **any** element of a collection.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passed the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // =&gt; true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // =&gt; true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">some</span>(<span class="hljs-params">collection, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">if</span> (isArray(collection)) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            length = collection.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">if</span> (predicate(collection[index], index, collection)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        }
      } <span class="hljs-keyword">else</span> {
        baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, collection</span>) </span>{
          <span class="hljs-keyword">return</span> !(result = predicate(value, index, collection));
        });
      }
      <span class="hljs-keyword">return</span> !!result;
    }

    <span class="hljs-comment">/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function
     *  called per iteration. If a property name or object is provided it will
     *  be used to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // =&gt; [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // =&gt; [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // =&gt; [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = &gt; [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortBy</span>(<span class="hljs-params">collection, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          multi = callback &amp;&amp; isArray(callback),
          length = collection ? collection.length : <span class="hljs-number">0</span>,
          result = <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> ? length : <span class="hljs-number">0</span>);

      <span class="hljs-keyword">if</span> (!multi) {
        callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);
      }
      baseEach(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, collection</span>) </span>{
        <span class="hljs-keyword">if</span> (multi) {
          <span class="hljs-keyword">var</span> length = callback.length,
              criteria = <span class="hljs-built_in">Array</span>(length);

          <span class="hljs-keyword">while</span> (length--) {
            criteria[length] = value[callback[length]];
          }
        } <span class="hljs-keyword">else</span> {
          criteria = callback(value, key, collection);
        }
        result[++index] = { <span class="hljs-string">'criteria'</span>: criteria, <span class="hljs-string">'index'</span>: index, <span class="hljs-string">'value'</span>: value };
      });

      length = result.length;
      result.sort(multi ? compareMultipleAscending : compareAscending);
      <span class="hljs-keyword">while</span> (length--) {
        result[length] = result[length].value;
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // =&gt; [2, 3, 4]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">collection</span>) </span>{
      <span class="hljs-keyword">if</span> (collection &amp;&amp; <span class="hljs-keyword">typeof</span> collection.length == <span class="hljs-string">'number'</span>) {
        <span class="hljs-keyword">return</span> (support.unindexedChars &amp;&amp; isString(collection))
          ? collection.split(<span class="hljs-string">''</span>)
          : slice(collection);
      }
      <span class="hljs-keyword">return</span> values(collection);
    }

    <span class="hljs-comment">/**
     * Performs a deep comparison between each element in `collection` and the
     * `source` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} source The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // =&gt; [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // =&gt; [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */</span>
    <span class="hljs-keyword">var</span> where = filter;

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // =&gt; logs 'Done saving!', after all saves have completed
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">after</span>(<span class="hljs-params">n, func</span>) </span>{
      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (--n &lt; <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        }
      };
    }

    <span class="hljs-comment">/**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * Note: Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [args] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // =&gt; 'hi fred'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">func, thisArg</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> createWrapper(func, BIND_FLAG, <span class="hljs-literal">null</span>, thisArg);
      }
      <span class="hljs-keyword">if</span> (func) {
        <span class="hljs-keyword">var</span> arity = func[expando] ? func[expando][<span class="hljs-number">2</span>] : func.length,
            partialArgs = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);

        arity -= partialArgs.length;
      }
      <span class="hljs-keyword">return</span> createWrapper(func, BIND_FLAG | PARTIAL_FLAG, arity, thisArg, partialArgs);
    }

    <span class="hljs-comment">/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * Note: This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // =&gt; logs 'clicked docs', when the button is clicked
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindAll</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">var</span> funcs = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ? baseFlatten(<span class="hljs-built_in">arguments</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>) : functions(object),
          index = -<span class="hljs-number">1</span>,
          length = funcs.length;

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> key = funcs[index];
        object[key] = createWrapper(object[key], BIND_FLAG, <span class="hljs-literal">null</span>, object);
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [args] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // =&gt; 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // =&gt; 'hiya fred!'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindKey</span>(<span class="hljs-params">object, key</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span>
        ? createWrapper(key, BIND_FLAG | BIND_KEY_FLAG, <span class="hljs-literal">null</span>, object)
        : createWrapper(key, BIND_FLAG | BIND_KEY_FLAG | PARTIAL_FLAG, <span class="hljs-literal">null</span>, object, slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>));
    }

    <span class="hljs-comment">/**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // =&gt; 'Hiya Penelope!'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> funcs = <span class="hljs-built_in">arguments</span>,
          funcsLength = funcs.length,
          length = funcsLength;

      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">if</span> (!isFunction(funcs[length])) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> length = funcsLength - <span class="hljs-number">1</span>,
            result = funcs[length].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

        <span class="hljs-keyword">while</span> (length--) {
          result = funcs[length].call(<span class="hljs-keyword">this</span>, result);
        }
        <span class="hljs-keyword">return</span> result;
      };
    }

    <span class="hljs-comment">/**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * Note: This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // =&gt; 6
     *
     * curried(1, 2)(3);
     * // =&gt; 6
     *
     * curried(1, 2, 3);
     * // =&gt; 6
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func, arity</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arity != <span class="hljs-string">'number'</span>) {
        arity = +arity || (func ? func.length : <span class="hljs-number">0</span>);
      }
      <span class="hljs-keyword">return</span> createWrapper(func, CURRY_FLAG, arity);
    }

    <span class="hljs-comment">/**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, options</span>) </span>{
      <span class="hljs-keyword">var</span> args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = <span class="hljs-number">0</span>,
          maxWait = <span class="hljs-literal">false</span>,
          trailing = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      wait = wait &gt; <span class="hljs-number">0</span> ? wait : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (options === <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> leading = <span class="hljs-literal">true</span>;
        trailing = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(options)) {
        leading = options.leading;
        maxWait = <span class="hljs-string">'maxWait'</span> <span class="hljs-keyword">in</span> options &amp;&amp; (nativeMax(wait, options.maxWait) || <span class="hljs-number">0</span>);
        trailing = <span class="hljs-string">'trailing'</span> <span class="hljs-keyword">in</span> options ? options.trailing : trailing;
      }
      <span class="hljs-keyword">var</span> delayed = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> remaining = wait - (now() - stamp);
        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) {
          <span class="hljs-keyword">if</span> (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          <span class="hljs-keyword">var</span> isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = <span class="hljs-literal">undefined</span>;
          <span class="hljs-keyword">if</span> (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            <span class="hljs-keyword">if</span> (!timeoutId &amp;&amp; !maxTimeoutId) {
              args = thisArg = <span class="hljs-literal">null</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      <span class="hljs-keyword">var</span> maxDelayed = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">if</span> (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          <span class="hljs-keyword">if</span> (!timeoutId &amp;&amp; !maxTimeoutId) {
            args = thisArg = <span class="hljs-literal">null</span>;
          }
        }
      };

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        args = <span class="hljs-built_in">arguments</span>;
        stamp = now();
        thisArg = <span class="hljs-keyword">this</span>;
        trailingCall = trailing &amp;&amp; (timeoutId || !leading);

        <span class="hljs-keyword">if</span> (maxWait === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">var</span> leadingCall = leading &amp;&amp; !timeoutId;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (!maxTimeoutId &amp;&amp; !leading) {
            lastCalled = stamp;
          }
          <span class="hljs-keyword">var</span> remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; maxWait;

          <span class="hljs-keyword">if</span> (isCalled) {
            <span class="hljs-keyword">if</span> (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        <span class="hljs-keyword">if</span> (isCalled &amp;&amp; timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timeoutId &amp;&amp; wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        <span class="hljs-keyword">if</span> (leadingCall) {
          isCalled = <span class="hljs-literal">true</span>;
          result = func.apply(thisArg, args);
        }
        <span class="hljs-keyword">if</span> (isCalled &amp;&amp; !timeoutId &amp;&amp; !maxTimeoutId) {
          args = thisArg = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> result;
      };
    }

    <span class="hljs-comment">/**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [args] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params">func</span>) </span>{
      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">var</span> args = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ func.apply(<span class="hljs-literal">undefined</span>, args); }, <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">/**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [args] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // =&gt; logs 'later' after one second
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">func, wait</span>) </span>{
      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">var</span> args = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
      <span class="hljs-keyword">return</span> setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ func.apply(<span class="hljs-literal">undefined</span>, args); }, wait);
    }

    <span class="hljs-comment">/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // =&gt; 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // =&gt; { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // =&gt; { 'name': 'penelope', 'age': 1 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span>(<span class="hljs-params">func, resolver</span>) </span>{
      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">var</span> memoized = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> cache = memoized.cache,
            key = resolver ? resolver.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) : <span class="hljs-string">'_'</span> + <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">return</span> hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
      }
      memoized.cache = {};
      <span class="hljs-keyword">return</span> memoized;
    }

    <span class="hljs-comment">/**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">func</span>) </span>{
      <span class="hljs-keyword">var</span> ran,
          result;

      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (ran) {
          <span class="hljs-keyword">return</span> result;
        }
        ran = <span class="hljs-literal">true</span>;
        result = func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>clear the <code>func</code> variable so the function may be garbage collected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        func = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> result;
      };
    }

    <span class="hljs-comment">/**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * Note: This method does not set the `length` property of partially applied
     * functions.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // =&gt; 'hi fred'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">func</span>) </span>{
      <span class="hljs-keyword">if</span> (func) {
        <span class="hljs-keyword">var</span> arity = func[expando] ? func[expando][<span class="hljs-number">2</span>] : func.length,
            partialArgs = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

        arity -= partialArgs.length;
      }
      <span class="hljs-keyword">return</span> createWrapper(func, PARTIAL_FLAG, arity, <span class="hljs-literal">null</span>, partialArgs);
    }

    <span class="hljs-comment">/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * Note: This method does not set the `length` property of partially applied
     * functions.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // =&gt; 'data'
     *
     * options.imports
     * // =&gt; { '_': _, 'jq': $ }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partialRight</span>(<span class="hljs-params">func</span>) </span>{
      <span class="hljs-keyword">if</span> (func) {
        <span class="hljs-keyword">var</span> arity = func[expando] ? func[expando][<span class="hljs-number">2</span>] : func.length,
            partialRightArgs = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

        arity -= partialRightArgs.length;
      }
      <span class="hljs-keyword">return</span> createWrapper(func, PARTIAL_RIGHT_FLAG, arity, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, partialRightArgs);
    }

    <span class="hljs-comment">/**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, options</span>) </span>{
      <span class="hljs-keyword">var</span> leading = <span class="hljs-literal">true</span>,
          trailing = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">if</span> (!isFunction(func)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>;
      }
      <span class="hljs-keyword">if</span> (options === <span class="hljs-literal">false</span>) {
        leading = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(options)) {
        leading = <span class="hljs-string">'leading'</span> <span class="hljs-keyword">in</span> options ? !!options.leading : leading;
        trailing = <span class="hljs-string">'trailing'</span> <span class="hljs-keyword">in</span> options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;

      <span class="hljs-keyword">return</span> debounce(func, wait, debounceOptions);
    }

    <span class="hljs-comment">/**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '&lt;p&gt;' + func(text) + '&lt;/p&gt;';
     * });
     *
     * p('fred, barney, &amp; pebbles');
     * // =&gt; '&lt;p&gt;fred, barney, &amp;amp; pebbles&lt;/p&gt;'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">value, wrapper</span>) </span>{
      <span class="hljs-keyword">return</span> createWrapper(wrapper, PARTIAL_FLAG, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, [value]);
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // =&gt; { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * defaults({ 'name': 'barney' }, { 'name': 'fred', 'employer': 'slate' });
     * // =&gt; { 'name': 'barney', 'employer': 'slate' }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assign</span>(<span class="hljs-params">object, source, guard</span>) </span>{
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
          argsIndex = <span class="hljs-number">0</span>,
          argsLength = args.length,
          type = <span class="hljs-keyword">typeof</span> guard;</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.reduce</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; args[<span class="hljs-number">3</span>] &amp;&amp; args[<span class="hljs-number">3</span>][guard] === source) {
        argsLength = <span class="hljs-number">2</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>juggle arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (argsLength &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[argsLength - <span class="hljs-number">2</span>] == <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> callback = baseCreateCallback(args[--argsLength - <span class="hljs-number">1</span>], args[argsLength--], <span class="hljs-number">2</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argsLength &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[argsLength - <span class="hljs-number">1</span>] == <span class="hljs-string">'function'</span>) {
        callback = args[--argsLength];
      }
      <span class="hljs-keyword">while</span> (++argsIndex &lt; argsLength) {
        source = args[argsIndex];
        <span class="hljs-keyword">if</span> (isObject(source)) {
          <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
              props = keys(source),
              length = props.length;

          <span class="hljs-keyword">while</span> (++index &lt; length) {
            <span class="hljs-keyword">var</span> key = props[index];
            object[key] = callback ? callback(object[key], source[key]) : source[key];
          }
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // =&gt; true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // =&gt; false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // =&gt; 0
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clone</span>(<span class="hljs-params">value, isDeep, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> isDeep;</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>juggle arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (type != <span class="hljs-string">'boolean'</span> &amp;&amp; isDeep != <span class="hljs-literal">null</span>) {
        thisArg = callback;
        callback = isDeep;
        isDeep = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.map</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; thisArg &amp;&amp; thisArg[callback] === value) {
          callback = <span class="hljs-literal">null</span>;
        }
      }
      callback = <span class="hljs-keyword">typeof</span> callback == <span class="hljs-string">'function'</span> &amp;&amp; baseCreateCallback(callback, thisArg, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> baseClone(value, isDeep, callback);
    }

    <span class="hljs-comment">/**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // =&gt; false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneDeep</span>(<span class="hljs-params">value, callback, thisArg</span>) </span>{
      callback = <span class="hljs-keyword">typeof</span> callback == <span class="hljs-string">'function'</span> &amp;&amp; baseCreateCallback(callback, thisArg, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> baseClone(value, <span class="hljs-literal">true</span>, callback);
    }

    <span class="hljs-comment">/**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // =&gt; true
     *
     * circle instanceof Shape;
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">prototype, properties</span>) </span>{
      <span class="hljs-keyword">var</span> result = baseCreate(prototype);
      <span class="hljs-keyword">return</span> properties ? assign(result, properties) : result;
    }

    <span class="hljs-comment">/**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.defaults({ 'name': 'barney' }, { 'name': 'fred', 'employer': 'slate' });
     * // =&gt; { 'name': 'barney', 'employer': 'slate' }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaults</span>(<span class="hljs-params">object, source, guard</span>) </span>{
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
          argsIndex = <span class="hljs-number">0</span>,
          argsLength = args.length,
          type = <span class="hljs-keyword">typeof</span> guard;</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.reduce</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; args[<span class="hljs-number">3</span>] &amp;&amp; args[<span class="hljs-number">3</span>][guard] === source) {
        argsLength = <span class="hljs-number">2</span>;
      }
      <span class="hljs-keyword">while</span> (++argsIndex &lt; argsLength) {
        source = args[argsIndex];
        <span class="hljs-keyword">if</span> (isObject(source)) {
          <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
              props = keys(source),
              length = props.length;

          <span class="hljs-keyword">while</span> (++index &lt; length) {
            <span class="hljs-keyword">var</span> key = props[index];
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> object[key] == <span class="hljs-string">'undefined'</span>) {
              object[key] = source[key];
            }
          }
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element the predicate returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': { 'age': 36 },
     *   'fred': { 'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1 }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age &lt; 40;
     * });
     * // =&gt; 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // =&gt; 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // =&gt; 'fred'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findKey</span>(<span class="hljs-params">object, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      baseForOwn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
        <span class="hljs-keyword">if</span> (predicate(value, key, object)) {
          result = key;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      });
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `predicate` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': { 'age': 36, 'blocked': true },
     *   'fred': { 'age': 40 },
     *   'pebbles': { 'age': 1, 'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age &lt; 40;
     * });
     * // =&gt; returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // =&gt; 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // =&gt; 'pebbles'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLastKey</span>(<span class="hljs-params">object, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result;

      predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
      baseForOwnRight(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
        <span class="hljs-keyword">if</span> (predicate(value, key, object)) {
          result = key;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      });
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // =&gt; logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forIn</span>(<span class="hljs-params">object, callback, thisArg</span>) </span>{
      callback = callback &amp;&amp; <span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> ? callback : baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">return</span> baseForIn(object, callback);
    }

    <span class="hljs-comment">/**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // =&gt; logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forInRight</span>(<span class="hljs-params">object, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> pairs = [];
      baseForIn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
        pairs.push(key, value);
      });

      <span class="hljs-keyword">var</span> length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">if</span> (callback(pairs[length--], pairs[length], object) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // =&gt; logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forOwn</span>(<span class="hljs-params">object, callback, thisArg</span>) </span>{
      callback = callback &amp;&amp; <span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> ? callback : baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">return</span> baseForOwn(object, callback);
    }

    <span class="hljs-comment">/**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // =&gt; logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forOwnRight</span>(<span class="hljs-params">object, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, <span class="hljs-number">3</span>);
      <span class="hljs-keyword">while</span> (length--) {
        <span class="hljs-keyword">var</span> key = props[length];
        <span class="hljs-keyword">if</span> (callback(object[key], key, object) === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // =&gt; ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functions</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">var</span> result = [];
      baseForIn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
        <span class="hljs-keyword">if</span> (isFunction(value)) {
          result.push(key);
        }
      });
      <span class="hljs-keyword">return</span> result.sort();
    }

    <span class="hljs-comment">/**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">object, key</span>) </span>{
      <span class="hljs-keyword">return</span> object ? hasOwnProperty.call(object, key) : <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Creates an object composed of the inverted keys and values of the given
     * object. If the given object contains duplicate values, subsequent values
     * will overwrite property assignments of previous values unless `multiValue`
     * is `true`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue=false] Allow multiple values per key.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // =&gt; { 'fred': 'first', 'barney': 'second' }
     *
     * // without `multiValue`
     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });
     * // =&gt; { 'fred': 'third', 'barney': 'second' }
     *
     * // with `multiValue`
     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);
     * // =&gt; { 'fred': ['first', 'third'], 'barney': ['second'] }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invert</span>(<span class="hljs-params">object, multiValue</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          props = keys(object),
          length = props.length,
          result = {};

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> key = props[index],
            value = object[key];

        <span class="hljs-keyword">if</span> (multiValue) {
          <span class="hljs-keyword">if</span> (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } <span class="hljs-keyword">else</span> {
            result[value] = [key];
          }
        }
        <span class="hljs-keyword">else</span> {
          result[value] = key;
        }
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // =&gt; false
     *
     * _.isArray([1, 2, 3]);
     * // =&gt; true
     */</span>
    <span class="hljs-keyword">var</span> isArray = nativeIsArray || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.length == <span class="hljs-string">'number'</span> &amp;&amp;
        toString.call(value) == arrayClass || <span class="hljs-literal">false</span>;
    };

    <span class="hljs-comment">/**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBoolean</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">true</span> || value === <span class="hljs-literal">false</span> ||
        value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; toString.call(value) == boolClass || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDate</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; toString.call(value) == dateClass || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isElement</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; value.nodeType === <span class="hljs-number">1</span> &amp;&amp;
        (support.nodeClass ? toString.call(value).indexOf(<span class="hljs-string">'Element'</span>) &gt; -<span class="hljs-number">1</span> : isNode(value)) || <span class="hljs-literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>fallback for environments without DOM support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!support.dom) {
      isElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; value.nodeType === <span class="hljs-number">1</span> &amp;&amp;
          !isPlainObject(value) || <span class="hljs-literal">false</span>;
      };
    }

    <span class="hljs-comment">/**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // =&gt; false
     *
     * _.isEmpty({});
     * // =&gt; true
     *
     * _.isEmpty('');
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmpty</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> result = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (!value) {
        <span class="hljs-keyword">return</span> result;
      }
      <span class="hljs-keyword">var</span> className = toString.call(value),
          length = value.length;

      <span class="hljs-keyword">if</span> ((className == arrayClass || className == stringClass ||
          (support.argsClass ? className == argsClass : isArguments(value))) ||
          (className == objectClass &amp;&amp; <span class="hljs-keyword">typeof</span> length == <span class="hljs-string">'number'</span> &amp;&amp; isFunction(value.splice))) {
        <span class="hljs-keyword">return</span> !length;
      }
      baseForOwn(value, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> (result = <span class="hljs-literal">false</span>);
      });
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // =&gt; false
     *
     * _.isEqual(object, copy);
     * // =&gt; true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) &amp;&amp; reGreet.test(a),
     *       bGreet = _.isString(b) &amp;&amp; reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">a, b, callback, thisArg</span>) </span>{
      callback = <span class="hljs-keyword">typeof</span> callback == <span class="hljs-string">'function'</span> &amp;&amp; baseCreateCallback(callback, thisArg, <span class="hljs-number">2</span>);

      <span class="hljs-keyword">if</span> (!callback) {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>exit early for identical values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (a === b) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>treat <code>-0</code> vs. <code>+0</code> as not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> || (<span class="hljs-number">1</span> / a == <span class="hljs-number">1</span> / b);
        }
        <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> a,
            otherType = <span class="hljs-keyword">typeof</span> b;</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>exit early for unlike primitive values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (a === a &amp;&amp; (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span> ||
            (type != <span class="hljs-string">'function'</span> &amp;&amp; type != <span class="hljs-string">'object'</span> &amp;&amp; otherType != <span class="hljs-string">'function'</span> &amp;&amp; otherType != <span class="hljs-string">'object'</span>))) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
      <span class="hljs-keyword">return</span> baseIsEqual(a, b, callback);
    }

    <span class="hljs-comment">/**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This method is not the same as native `isFinite` which will return
     * `true` for booleans and empty strings. See the [ES5 spec](http://es5.github.io/#x15.1.2.5)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // =&gt; true
     *
     * _.isFinite('10');
     * // =&gt; true
     *
     * _.isFinite(true);
     * // =&gt; false
     *
     * _.isFinite('');
     * // =&gt; false
     *
     * _.isFinite(Infinity);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFinite</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> nativeIsFinite(value) &amp;&amp; !nativeIsNaN(<span class="hljs-built_in">parseFloat</span>(value));
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'function'</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>fallback for older versions of Chrome and Safari</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (isFunction(<span class="hljs-regexp">/x/</span>)) {
      isFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'function'</span> &amp;&amp; toString.call(value) == funcClass;
      };
    }

    <span class="hljs-comment">/**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // =&gt; true
     *
     * _.isObject([1, 2, 3]);
     * // =&gt; true
     *
     * _.isObject(1);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>check if the value is the ECMAScript language type of Object
<a href="http://es5.github.io/#x8">http://es5.github.io/#x8</a>
and avoid a V8 bug
<a href="https://code.google.com/p/v8/issues/detail?id=2291">https://code.google.com/p/v8/issues/detail?id=2291</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> value;
      <span class="hljs-keyword">return</span> value &amp;&amp; (type == <span class="hljs-string">'function'</span> || type == <span class="hljs-string">'object'</span>) || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is `NaN`.
     *
     * Note: This method is not the same as native `isNaN` which will return `true`
     * for `undefined` and other non-numeric values. See the [ES5 spec](http://es5.github.io/#x15.1.2.4)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // =&gt; true
     *
     * _.isNaN(new Number(NaN));
     * // =&gt; true
     *
     * isNaN(undefined);
     * // =&gt; true
     *
     * _.isNaN(undefined);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNaN</span>(<span class="hljs-params">value</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p><code>NaN</code> as a primitive is the only value that is not equal to itself
(perform the [[Class]] check first to avoid errors with some host objects in IE)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> isNumber(value) &amp;&amp; value != +value;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // =&gt; true
     *
     * _.isNull(undefined);
     * // =&gt; false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNull</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value === <span class="hljs-literal">null</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See the [ES5 spec](http://es5.github.io/#x8.5)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> value;
      <span class="hljs-keyword">return</span> type == <span class="hljs-string">'number'</span> ||
        value &amp;&amp; type == <span class="hljs-string">'object'</span> &amp;&amp; toString.call(value) == numberClass || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // =&gt; false
     *
     * _.isPlainObject([1, 2, 3]);
     * // =&gt; false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // =&gt; true
     */</span>
    <span class="hljs-keyword">var</span> isPlainObject = !getPrototypeOf ? shimIsPlainObject : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">if</span> (!(value &amp;&amp; toString.call(value) == objectClass) || (!support.argsClass &amp;&amp; isArguments(value))) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">var</span> valueOf = value.valueOf,
          objProto = isNative(valueOf) &amp;&amp; (objProto = getPrototypeOf(valueOf)) &amp;&amp; getPrototypeOf(objProto);

      <span class="hljs-keyword">return</span> objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    <span class="hljs-comment">/**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRegExp</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> value;
      <span class="hljs-keyword">return</span> value &amp;&amp; (type == <span class="hljs-string">'function'</span> || type == <span class="hljs-string">'object'</span>) &amp;&amp;
        toString.call(value) == regexpClass || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'string'</span> ||
        value &amp;&amp; <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; toString.call(value) == stringClass || <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndefined</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span>;
    }

    <span class="hljs-comment">/**
     * Creates an array composed of the own enumerable property names of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // =&gt; ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-keyword">var</span> keys = !nativeKeys ? shimKeys : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">if</span> (!isObject(object)) {
        <span class="hljs-keyword">return</span> [];
      }
      <span class="hljs-keyword">if</span> ((support.enumPrototypes &amp;&amp; <span class="hljs-keyword">typeof</span> object == <span class="hljs-string">'function'</span>) ||
          (support.nonEnumArgs &amp;&amp; object.length &amp;&amp; isArguments(object))) {
        <span class="hljs-keyword">return</span> shimKeys(object);
      }
      <span class="hljs-keyword">return</span> nativeKeys(object);
    };

    <span class="hljs-comment">/**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // =&gt; { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // =&gt; { 'fred': 40, 'pebbles': 1 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapValues</span>(<span class="hljs-params">object, callback, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result = {};

      callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">3</span>);
      baseForOwn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
        result[key] = callback(value, key, object);
      });
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // =&gt; { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // =&gt; { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">object, source, guard</span>) </span>{
      <span class="hljs-keyword">if</span> (!isObject(object)) {
        <span class="hljs-keyword">return</span> object;
      }
      <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
          length = args.length,
          type = <span class="hljs-keyword">typeof</span> guard;</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>enables use as a callback for functions like <code>_.reduce</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((type == <span class="hljs-string">'number'</span> || type == <span class="hljs-string">'string'</span>) &amp;&amp; args[<span class="hljs-number">3</span>] &amp;&amp; args[<span class="hljs-number">3</span>][guard] === source) {
        length = <span class="hljs-number">2</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>juggle arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[length - <span class="hljs-number">2</span>] == <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> callback = baseCreateCallback(args[--length - <span class="hljs-number">1</span>], args[length--], <span class="hljs-number">2</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> args[length - <span class="hljs-number">1</span>] == <span class="hljs-string">'function'</span>) {
        callback = args[--length];
      }
      <span class="hljs-keyword">var</span> sources = slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>, length),
          index = -<span class="hljs-number">1</span>,
          stackA = [],
          stackB = [];

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      <span class="hljs-keyword">return</span> object;
    }

    <span class="hljs-comment">/**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a predicate is provided it will be executed for each
     * property of `object` omitting the properties the predicate returns truthy
     * for. The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [predicate] The function called per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // =&gt; { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // =&gt; { 'name': 'fred' }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">omit</span>(<span class="hljs-params">object, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result = {};

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> omitProps = baseFlatten(<span class="hljs-built_in">arguments</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>),
            length = omitProps.length;

        <span class="hljs-keyword">while</span> (length--) {
          omitProps[length] = <span class="hljs-built_in">String</span>(omitProps[length]);
        }
        <span class="hljs-keyword">var</span> props = [];
        baseForIn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
          props.push(key);
        });

        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>;
        props = baseDifference(props, omitProps);
        length = props.length;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> key = props[index];
          result[key] = object[key];
        }
      } <span class="hljs-keyword">else</span> {
        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        baseForIn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
          <span class="hljs-keyword">if</span> (!predicate(value, key, object)) {
            result[key] = value;
          }
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates a two dimensional array of a given object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // =&gt; [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pairs</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          props = keys(object),
          length = props.length,
          result = <span class="hljs-built_in">Array</span>(length);

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> key = props[index];
        result[index] = [key, object[key]];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a predicate is provided it will be executed for each
     * property of `object` picking the properties the predicate returns truthy
     * for. The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [predicate] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // =&gt; { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // =&gt; { 'name': 'fred' }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pick</span>(<span class="hljs-params">object, predicate, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> result = {};

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> predicate != <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
            props = baseFlatten(<span class="hljs-built_in">arguments</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>),
            length = isObject(object) ? props.length : <span class="hljs-number">0</span>;

        <span class="hljs-keyword">while</span> (++index &lt; length) {
          <span class="hljs-keyword">var</span> key = props[index];
          <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> object) {
            result[key] = object[key];
          }
        }
      } <span class="hljs-keyword">else</span> {
        predicate = lodash.createCallback(predicate, thisArg, <span class="hljs-number">3</span>);
        baseForIn(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, object</span>) </span>{
          <span class="hljs-keyword">if</span> (predicate(value, key, object)) {
            result[key] = value;
          }
        });
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) &lt; 3;
     *   }
     * });
     * // =&gt; [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // =&gt; { 'a': 3, 'b': 6, 'c': 9 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params">object, callback, accumulator, thisArg</span>) </span>{
      <span class="hljs-keyword">var</span> isArr = isArray(object);
      <span class="hljs-keyword">if</span> (accumulator == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (isArr) {
          accumulator = [];
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> ctor = object &amp;&amp; object.constructor,
              proto = ctor &amp;&amp; ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      <span class="hljs-keyword">if</span> (callback) {
        callback = lodash.createCallback(callback, thisArg, <span class="hljs-number">4</span>);
        (isArr ? baseEach : baseForOwn)(object, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, object</span>) </span>{
          <span class="hljs-keyword">return</span> callback(accumulator, value, index, object);
        });
      }
      <span class="hljs-keyword">return</span> accumulator;
    }

    <span class="hljs-comment">/**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // =&gt; [1, 2, 3] (property order is not guaranteed across environments)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">values</span>(<span class="hljs-params">object</span>) </span>{
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          props = keys(object),
          length = props.length,
          result = <span class="hljs-built_in">Array</span>(length);

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        result[index] = object[props[index]];
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Converts `string` to camel case.
     * See [Wikipedia](http://en.wikipedia.org/wiki/CamelCase) for more details.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to camel case.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Hello world');
     * // =&gt; 'helloWorld'
     *
     * _.camelCase('hello-world');
     * // =&gt; 'helloWorld'
     *
     * _.camelCase('hello_world');
     * // =&gt; 'helloWorld'
     */</span>
    <span class="hljs-keyword">var</span> camelCase = createCompounder(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, word, index</span>) </span>{
      <span class="hljs-keyword">return</span> result + word.charAt(<span class="hljs-number">0</span>)[index ? <span class="hljs-string">'toUpperCase'</span> : <span class="hljs-string">'toLowerCase'</span>]() + word.slice(<span class="hljs-number">1</span>);
    });

    <span class="hljs-comment">/**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // =&gt; 'Fred'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalize</span>(<span class="hljs-params">string</span>) </span>{
      <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      string = <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">return</span> string.charAt(<span class="hljs-number">0</span>).toUpperCase() + string.slice(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">/**
     * Checks if `string` ends with a given target string.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if the given string ends with the
     *  target string, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // =&gt; true
     *
     * _.endsWith('abc', 'b');
     * // =&gt; false
     *
     * _.endsWith('abc', 'b', 2);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endsWith</span>(<span class="hljs-params">string, target, position</span>) </span>{
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      target = <span class="hljs-built_in">String</span>(target);

      <span class="hljs-keyword">var</span> length = string.length;
      position = (<span class="hljs-keyword">typeof</span> position == <span class="hljs-string">'number'</span> ? nativeMin(nativeMax(position, <span class="hljs-number">0</span>), length) : length) - target.length;
      <span class="hljs-keyword">return</span> position &gt;= <span class="hljs-number">0</span> &amp;&amp; string.indexOf(target, position) == position;
    }

    <span class="hljs-comment">/**
     * Converts the characters "&amp;", "&lt;", "&gt;", '"', and "'" in `string` to
     * their corresponding HTML entities.
     *
     * Note: No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](http://mths.be/he).
     *
     * When working with HTML you should always quote attribute values to reduce
     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, &amp; pebbles');
     * // =&gt; 'fred, barney, &amp;amp; pebbles'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escape</span>(<span class="hljs-params">string</span>) </span>{
      <span class="hljs-keyword">return</span> string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    <span class="hljs-comment">/**
     * Escapes the RegExp special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](http://lodash.com)');
     * // =&gt; '\[lodash\]\(http://lodash\.com\)'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">escapeRegExp</span>(<span class="hljs-params">string</span>) </span>{
      <span class="hljs-keyword">return</span> string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string).replace(reRegExpChars, <span class="hljs-string">'\\$&amp;'</span>);
    }

    <span class="hljs-comment">/**
     * Converts `string` to kebab case (a.k.a. spinal case).
     * See [Wikipedia](http://en.wikipedia.org/wiki/Letter_case#Computers) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to kebab case.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Hello world');
     * // =&gt; 'hello-world'
     *
     * _.kebabCase('helloWorld');
     * // =&gt; 'hello-world'
     *
     * _.kebabCase('hello_world');
     * // =&gt; 'hello-world'
     */</span>
    <span class="hljs-keyword">var</span> kebabCase = createCompounder(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, word, index</span>) </span>{
      <span class="hljs-keyword">return</span> result + (index ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>) + word.toLowerCase();
    });

    <span class="hljs-comment">/**
     * Pads `string` on the left and right sides if it is shorter then the given
     * padding length. The `chars` string may be truncated if the number of padding
     * characters can't be evenly divided by the padding length.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // =&gt; '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // =&gt; '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // =&gt; 'abc'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pad</span>(<span class="hljs-params">string, length, chars</span>) </span>{
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      length = +length || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> strLength = string.length;
      <span class="hljs-keyword">if</span> (strLength &gt;= length) {
        <span class="hljs-keyword">return</span> string;
      }
      <span class="hljs-keyword">var</span> mid = (length - strLength) / <span class="hljs-number">2</span>,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPad(<span class="hljs-string">''</span>, rightLength, chars);
      <span class="hljs-keyword">return</span> chars.slice(<span class="hljs-number">0</span>, leftLength) + string + chars;
    }

    <span class="hljs-comment">/**
     * Pads `string` on the left side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // =&gt; '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // =&gt; '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // =&gt; 'abc'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padLeft</span>(<span class="hljs-params">string, length, chars</span>) </span>{
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">return</span> createPad(string, length, chars) + string;
    }

    <span class="hljs-comment">/**
     * Pads `string` on the right side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // =&gt; 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // =&gt; 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // =&gt; 'abc'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">padRight</span>(<span class="hljs-params">string, length, chars</span>) </span>{
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">return</span> string + createPad(string, length, chars);
    }

    <span class="hljs-comment">/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // =&gt; '***'
     *
     * _.repeat('abc', 2);
     * // =&gt; 'abcabc'
     *
     * _.repeat('abc', 0);
     * // =&gt; ''
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">string, n</span>) </span>{
      <span class="hljs-keyword">var</span> result = <span class="hljs-string">''</span>;
      n = +n || <span class="hljs-number">0</span>;

      <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> result;
      }
      string = <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) {
          result += string;
        }
        n = floor(n / <span class="hljs-number">2</span>);
        string += string;
      } <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>);
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Converts `string` to snake case.
     * See [Wikipedia](http://en.wikipedia.org/wiki/Snake_case) for more details.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to snake case.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Hello world');
     * // =&gt; 'hello_world'
     *
     * _.snakeCase('hello-world');
     * // =&gt; 'hello_world'
     *
     * _.snakeCase('helloWorld');
     * // =&gt; 'hello_world'
     */</span>
    <span class="hljs-keyword">var</span> snakeCase = createCompounder(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result, word, index</span>) </span>{
      <span class="hljs-keyword">return</span> result + (index ? <span class="hljs-string">'_'</span> : <span class="hljs-string">''</span>) + word.toLowerCase();
    });

    <span class="hljs-comment">/**
     * Checks if `string` starts with a given target string.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if the given string starts with the
     *  target string, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // =&gt; true
     *
     * _.startsWith('abc', 'b');
     * // =&gt; false
     *
     * _.startsWith('abc', 'b', 1);
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startsWith</span>(<span class="hljs-params">string, target, position</span>) </span>{
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      position = <span class="hljs-keyword">typeof</span> position == <span class="hljs-string">'number'</span> ? nativeMin(nativeMax(position, <span class="hljs-number">0</span>), string.length) : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> string.lastIndexOf(target, position) == position;
    }

    <span class="hljs-comment">/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escaped interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. If
     * a data object is provided the interpolated template string will be returned.
     * Data properties may be accessed as free variables in the template. If a
     * settings object is provided it will override `_.templateSettings` for the
     * template.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier debugging.
     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for more details.
     *
     * For more information on precompiling templates see
     * [Lo-Dash's custom builds documentation](http://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](http://developer.chrome.com/stable/extensions/sandboxingEval.html).
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The template string.
     * @param {Object} [data] The data object used to populate the template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @returns {Function|string} Returns the interpolated string if a data object
     *  is provided, else it returns a template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello &lt;%= name %&gt;');
     * compiled({ 'name': 'fred' });
     * // =&gt; 'hello fred'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * _.template('&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;', { 'value': '&lt;script&gt;' });
     * // =&gt; '&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var list = '&lt;% _.forEach(people, function(name) { %&gt;&lt;li&gt;&lt;%- name %&gt;&lt;/li&gt;&lt;% }); %&gt;';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // =&gt; 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('&lt;% print("hello " + name); %&gt;!', { 'name': 'barney' });
     * // =&gt; 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // =&gt; 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '&lt;% jq.each(people, function(name) { %&gt;&lt;li&gt;&lt;%- name %&gt;&lt;/li&gt;&lt;% }); %&gt;';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // =&gt; '&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello &lt;%= name %&gt;', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // =&gt; find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi &lt;%= data.name %&gt;!', null, { 'variable': 'data' });
     * compiled.source;
     * // =&gt; function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">template</span>(<span class="hljs-params">string, data, options</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>based on John Resig’s <code>tmpl</code> implementation
<a href="http://ejohn.org/blog/javascript-micro-templating/">http://ejohn.org/blog/javascript-micro-templating/</a>
and Laura Doktorova’s doT.js
<a href="https://github.com/olado/doT">https://github.com/olado/doT</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> settings = lodash.templateSettings;
      string = <span class="hljs-built_in">String</span>(string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : string);</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>avoid missing dependencies when <code>iteratorTemplate</code> is not defined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      options = iteratorTemplate ? defaults({}, options, settings) : settings;

      <span class="hljs-keyword">var</span> imports = iteratorTemplate &amp;&amp; defaults({}, options.imports, settings.imports),
          importsKeys = iteratorTemplate ? keys(imports) : [<span class="hljs-string">'_'</span>],
          importsValues = iteratorTemplate ? values(imports) : [lodash];

      <span class="hljs-keyword">var</span> isEscaping,
          isEvaluating,
          index = <span class="hljs-number">0</span>,
          interpolate = options.interpolate || reNoMatch,
          source = <span class="hljs-string">"__p += '"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>compile the regexp to match each delimiter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> reDelimiters = <span class="hljs-built_in">RegExp</span>(
        (options.escape || reNoMatch).source + <span class="hljs-string">'|'</span> +
        interpolate.source + <span class="hljs-string">'|'</span> +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + <span class="hljs-string">'|'</span> +
        (options.evaluate || reNoMatch).source + <span class="hljs-string">'|$'</span>
      , <span class="hljs-string">'g'</span>);

      string.replace(reDelimiters, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset</span>) </span>{
        interpolateValue || (interpolateValue = esTemplateValue);</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>escape characters that cannot be included in string literals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>replace delimiters with snippets</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (escapeValue) {
          isEscaping = <span class="hljs-literal">true</span>;
          source += <span class="hljs-string">"' +\n__e("</span> + escapeValue + <span class="hljs-string">") +\n'"</span>;
        }
        <span class="hljs-keyword">if</span> (evaluateValue) {
          isEvaluating = <span class="hljs-literal">true</span>;
          source += <span class="hljs-string">"';\n"</span> + evaluateValue + <span class="hljs-string">";\n__p += '"</span>;
        }
        <span class="hljs-keyword">if</span> (interpolateValue) {
          source += <span class="hljs-string">"' +\n((__t = ("</span> + interpolateValue + <span class="hljs-string">")) == null ? '' : __t) +\n'"</span>;
        }
        index = offset + match.length;</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>the JS engine embedded in Adobe products requires returning the <code>match</code>
string in order to produce the correct <code>offset</code> value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> match;
      });

      source += <span class="hljs-string">"';\n"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>if <code>variable</code> is not specified, wrap a with-statement around the generated
code to add the data object to the top of the scope chain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> variable = options.variable;
      <span class="hljs-keyword">if</span> (!variable) {
        source = <span class="hljs-string">'with (obj) {\n'</span> + source + <span class="hljs-string">'\n}\n'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>cleanup code by stripping empty strings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      source = (isEvaluating ? source.replace(reEmptyStringLeading, <span class="hljs-string">''</span>) : source)
        .replace(reEmptyStringMiddle, <span class="hljs-string">'$1'</span>)
        .replace(reEmptyStringTrailing, <span class="hljs-string">'$1;'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>frame code as the function body</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      source = <span class="hljs-string">'function('</span> + (variable || <span class="hljs-string">'obj'</span>) + <span class="hljs-string">') {\n'</span> +
        (variable
          ? <span class="hljs-string">''</span>
          : <span class="hljs-string">'obj || (obj = {});\n'</span>
        ) +
        <span class="hljs-string">"var __t, __p = ''"</span> +
        (isEscaping
           ? <span class="hljs-string">', __e = _.escape'</span>
           : <span class="hljs-string">''</span>
        ) +
        (isEvaluating
          ? <span class="hljs-string">', __j = Array.prototype.join;\n'</span> +
            <span class="hljs-string">"function print() { __p += __j.call(arguments, '') }\n"</span>
          : <span class="hljs-string">';\n'</span>
        ) +
        source +
        <span class="hljs-string">'return __p\n}'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Use a sourceURL for easier debugging.
<a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl">http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">'\n/*\n//# sourceURL='</span> + (options.sourceURL || <span class="hljs-string">'/lodash/template/source['</span> + (templateCounter++) + <span class="hljs-string">']'</span>) + <span class="hljs-string">'\n*/'</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Function</span>(importsKeys, <span class="hljs-string">'return '</span> + source + sourceURL).apply(<span class="hljs-literal">undefined</span>, importsValues);
      } <span class="hljs-keyword">catch</span>(e) {
        e.source = source;
        <span class="hljs-keyword">throw</span> e;
      }
      <span class="hljs-keyword">if</span> (data) {
        <span class="hljs-keyword">return</span> result(data);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>provide the compiled function’s source by its <code>toString</code> method, in
supported environments, or the <code>source</code> property as a convenience for
inlining compiled templates during the build process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      result.source = source;
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  fred  ');
     * // =&gt; 'fred'
     *
     * _.trim('-_-fred-_-', '_-');
     * // =&gt; 'fred'
     */</span>
    <span class="hljs-keyword">var</span> trim = !nativeTrim ? shimTrim : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, chars</span>) </span>{
      <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      <span class="hljs-keyword">return</span> chars == <span class="hljs-literal">null</span> ? nativeTrim.call(string) : shimTrim(string, chars);
    };

    <span class="hljs-comment">/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  fred  ');
     * // =&gt; 'fred  '
     *
     * _.trimLeft('-_-fred-_-', '_-');
     * // =&gt; 'fred-_-'
     */</span>
    <span class="hljs-keyword">var</span> trimLeft = !nativeTrimLeft ? shimTrimLeft : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, chars</span>) </span>{
      <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      <span class="hljs-keyword">return</span> chars == <span class="hljs-literal">null</span> ? nativeTrimLeft.call(string) : shimTrimLeft(string, chars);
    };

    <span class="hljs-comment">/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  fred  ');
     * // =&gt; '  fred'
     *
     * _.trimRight('-_-fred-_-', '_-');
     * // =&gt; '-_-fred'
     */</span>
    <span class="hljs-keyword">var</span> trimRight = !nativeTrimRight ? shimTrimRight : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">string, chars</span>) </span>{
      <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      <span class="hljs-keyword">return</span> chars == <span class="hljs-literal">null</span> ? nativeTrimRight.call(string) : shimTrimRight(string, chars);
    };

    <span class="hljs-comment">/**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string will be replaced with the
     * omission string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to trim.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string used to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // =&gt; 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', 24);
     * // =&gt; 'hi-diddly-ho there, n...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });
     * // =&gt; 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });
     * //=&gt; 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });
     * // =&gt; 'hi-diddly-ho there, neig [...]'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">truncate</span>(<span class="hljs-params">string, options</span>) </span>{
      <span class="hljs-keyword">var</span> length = <span class="hljs-number">30</span>,
          omission = <span class="hljs-string">'...'</span>;

      <span class="hljs-keyword">if</span> (options &amp;&amp; isObject(options)) {
        <span class="hljs-keyword">var</span> separator = <span class="hljs-string">'separator'</span> <span class="hljs-keyword">in</span> options ? options.separator : separator;
        length = <span class="hljs-string">'length'</span> <span class="hljs-keyword">in</span> options ? +options.length || <span class="hljs-number">0</span> : length;
        omission = <span class="hljs-string">'omission'</span> <span class="hljs-keyword">in</span> options ? <span class="hljs-built_in">String</span>(options.omission) : omission;
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options != <span class="hljs-literal">null</span>) {
        length = +options || <span class="hljs-number">0</span>;
      }
      string = string == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">if</span> (length &gt; string.length) {
        <span class="hljs-keyword">return</span> string;
      }
      <span class="hljs-keyword">var</span> end = length - omission.length;
      <span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> omission;
      }
      <span class="hljs-keyword">var</span> result = string.slice(<span class="hljs-number">0</span>, end);
      <span class="hljs-keyword">if</span> (separator == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> result + omission;
      }
      <span class="hljs-keyword">if</span> (isRegExp(separator)) {
        <span class="hljs-keyword">if</span> (string.slice(end).search(separator)) {
          <span class="hljs-keyword">var</span> match,
              newEnd,
              substring = string.slice(<span class="hljs-number">0</span>, end);

          <span class="hljs-keyword">if</span> (!separator.global) {
            separator = <span class="hljs-built_in">RegExp</span>(separator.source, (reFlags.exec(separator) || <span class="hljs-string">''</span>) + <span class="hljs-string">'g'</span>);
          }
          separator.lastIndex = <span class="hljs-number">0</span>;
          <span class="hljs-keyword">while</span> ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(<span class="hljs-number">0</span>, newEnd == <span class="hljs-literal">null</span> ? end : newEnd);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (string.indexOf(separator, end) != end) {
        <span class="hljs-keyword">var</span> index = result.lastIndexOf(separator);
        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
          result = result.slice(<span class="hljs-number">0</span>, index);
        }
      }
      <span class="hljs-keyword">return</span> result + omission;
    }

    <span class="hljs-comment">/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;amp;`, `&amp;lt;`, `&amp;gt;`, `&amp;quot;`, and `&amp;#39;` in `string` to their
     * corresponding characters.
     *
     * Note: No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](http://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category Strings
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney &amp;amp; pebbles');
     * // =&gt; 'fred, barney &amp; pebbles'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unescape</span>(<span class="hljs-params">string</span>) </span>{
      <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      }
      string = <span class="hljs-built_in">String</span>(string);
      <span class="hljs-keyword">return</span> string.indexOf(<span class="hljs-string">';'</span>) &lt; <span class="hljs-number">0</span> ? string : string.replace(reEscapedHtml, unescapeHtmlChar);
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constant</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> value;
      };
    }

    <span class="hljs-comment">/**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @alias callback
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] &gt; match[3] : object[match[1]] &lt; match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // =&gt; [{ 'name': 'fred', 'age': 40 }]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCallback</span>(<span class="hljs-params">func, thisArg, argCount</span>) </span>{
      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span> func;
      <span class="hljs-keyword">if</span> (type == <span class="hljs-string">'function'</span> || func == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> thisArg == <span class="hljs-string">'undefined'</span> || !(<span class="hljs-string">'prototype'</span> <span class="hljs-keyword">in</span> func)) &amp;&amp;
          func || baseCreateCallback(func, thisArg, argCount);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>handle “<em>.pluck” and “</em>.where” style callback shorthands</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> type != <span class="hljs-string">'object'</span> ? property(func) : matches(func);
    }

    <span class="hljs-comment">/**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-comment">/**
     * Creates a "_.where" style predicate function which performs a deep comparison
     * between a given object and the `source` object, returning `true` if the given
     * object has equivalent property values, else `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var matchesAge = _.matches({ 'age': 36 });
     *
     * _.filter(characters, matchesAge);
     * // =&gt; [{ 'name': 'barney', 'age': 36 }]
     *
     * _.find(characters, matchesAge);
     * // =&gt; { 'name': 'barney', 'age': 36 }
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matches</span>(<span class="hljs-params">source</span>) </span>{
      source || (source = {});

      <span class="hljs-keyword">var</span> props = keys(source),
          key = props[<span class="hljs-number">0</span>],
          a = source[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>fast path the common case of providing an object with a single
property containing a primitive value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (props.length == <span class="hljs-number">1</span> &amp;&amp; a === a &amp;&amp; !isObject(a)) {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object</span>) </span>{
          <span class="hljs-keyword">if</span> (!hasOwnProperty.call(object, key)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>treat <code>-0</code> vs. <code>+0</code> as not equal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> b = object[key];
          <span class="hljs-keyword">return</span> a === b &amp;&amp; (a !== <span class="hljs-number">0</span> || (<span class="hljs-number">1</span> / a == <span class="hljs-number">1</span> / b));
        };
      }
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object</span>) </span>{
        <span class="hljs-keyword">var</span> length = props.length,
            result = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">while</span> (length--) {
          <span class="hljs-keyword">var</span> key = props[length];
          <span class="hljs-keyword">if</span> (!(result = hasOwnProperty.call(object, key) &amp;&amp;
                baseIsEqual(object[key], source[key], <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))) {
            <span class="hljs-keyword">break</span>;
          }
        }
        <span class="hljs-keyword">return</span> result;
      };
    }

    <span class="hljs-comment">/**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // =&gt; ['e']
     *
     * _('fred').vowels().value();
     * // =&gt; ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // =&gt; ['e']
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixin</span>(<span class="hljs-params">object, source, options</span>) </span>{
      <span class="hljs-keyword">var</span> chain = <span class="hljs-literal">true</span>,
          methodNames = source &amp;&amp; functions(source);

      <span class="hljs-keyword">if</span> (!source || (!options &amp;&amp; !methodNames.length)) {
        <span class="hljs-keyword">if</span> (options == <span class="hljs-literal">null</span>) {
          options = source;
        }
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      <span class="hljs-keyword">if</span> (options === <span class="hljs-literal">false</span>) {
        chain = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(options) &amp;&amp; <span class="hljs-string">'chain'</span> <span class="hljs-keyword">in</span> options) {
        chain = options.chain;
      }
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          isFunc = isFunction(object),
          length = methodNames ? methodNames.length : <span class="hljs-number">0</span>;

      <span class="hljs-keyword">while</span> (++index &lt; length) {
        <span class="hljs-keyword">var</span> methodName = methodNames[index],
            func = object[methodName] = source[methodName];

        <span class="hljs-keyword">if</span> (isFunc) {
          object.prototype[methodName] = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
              <span class="hljs-keyword">var</span> chainAll = <span class="hljs-keyword">this</span>.__chain__,
                  value = <span class="hljs-keyword">this</span>.__wrapped__,
                  args = [value];

              push.apply(args, <span class="hljs-built_in">arguments</span>);
              <span class="hljs-keyword">var</span> result = func.apply(object, args);
              <span class="hljs-keyword">if</span> (chain || chainAll) {
                <span class="hljs-keyword">if</span> (value === result &amp;&amp; isObject(result)) {
                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                }
                result = <span class="hljs-keyword">new</span> object(result);
                result.__chain__ = chainAll;
              }
              <span class="hljs-keyword">return</span> result;
            };
          }(func));
        }
      }
    }

    <span class="hljs-comment">/**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noConflict</span>(<span class="hljs-params"></span>) </span>{
      context._ = oldDash;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-comment">/**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // =&gt; true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>no operation performed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    }

    <span class="hljs-comment">/**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // =&gt; logs the number of milliseconds it took for the deferred function to be called
     */</span>
    <span class="hljs-keyword">var</span> now = nativeNow || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
    };

    <span class="hljs-comment">/**
     * Converts `value` to an integer of the specified radix. If `radix` is
     * `undefined` or `0` a `radix` of `10` is used unless the `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See the [ES5 spec](http://es5.github.io/#E)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // =&gt; 8
     */</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">parseInt</span> = nativeParseInt(whitespace + <span class="hljs-string">'08'</span>) == <span class="hljs-number">8</span> ? nativeParseInt : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, radix</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Firefox &lt; 21 and Opera &lt; 15 follow ES3  for <code>parseInt</code> and
Chrome fails to trim leading <BOM> whitespace characters.
See <a href="https://code.google.com/p/v8/issues/detail?id=3109">https://code.google.com/p/v8/issues/detail?id=3109</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      value = trim(value);
      <span class="hljs-keyword">return</span> nativeParseInt(value, +radix || (reHexPrefix.test(value) ? <span class="hljs-number">16</span> : <span class="hljs-number">10</span>));
    };

    <span class="hljs-comment">/**
     * Creates a "_.pluck" style function which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // =&gt; ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // =&gt; [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">property</span>(<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object</span>) </span>{
        <span class="hljs-keyword">return</span> object[key];
      };
    }

    <span class="hljs-comment">/**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truthy or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // =&gt; an integer between 0 and 5
     *
     * _.random(5);
     * // =&gt; also an integer between 0 and 5
     *
     * _.random(5, true);
     * // =&gt; a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // =&gt; a floating-point number between 1.2 and 5.2
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params">min, max, floating</span>) </span>{
      <span class="hljs-keyword">var</span> noMin = min == <span class="hljs-literal">null</span>,
          noMax = max == <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (floating == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (noMax &amp;&amp; <span class="hljs-keyword">typeof</span> min == <span class="hljs-string">'boolean'</span>) {
          floating = min;
          min = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> max == <span class="hljs-string">'boolean'</span>) {
          floating = max;
          noMax = <span class="hljs-literal">true</span>;
        }
      }
      <span class="hljs-keyword">if</span> (noMin &amp;&amp; noMax) {
        max = <span class="hljs-number">1</span>;
        noMax = <span class="hljs-literal">false</span>;
      }
      min = +min || <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (noMax) {
        max = min;
        min = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        max = +max || <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">if</span> (floating || min % <span class="hljs-number">1</span> || max % <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> rand = nativeRandom();
        <span class="hljs-keyword">return</span> nativeMin(min + (rand * (max - min + <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">'1e-'</span> + ((rand +<span class="hljs-string">''</span>).length - <span class="hljs-number">1</span>)))), max);
      }
      <span class="hljs-keyword">return</span> baseRandom(min, max);
    }

    <span class="hljs-comment">/**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result
     * returned, else the property value is returned. If `object` is `null` or
     * `undefined` then `undefined` is returned. If a default value is provided
     * it will be returned if the property value resolves to `undefined`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'age': function() {
     *     return 40;
     *   }
     * };
     *
     * _.result(object, 'name');
     * // =&gt; 'fred'
     *
     * _.result(object, 'age');
     * // =&gt; 40
     *
     * _.result(object, 'employer', 'slate');
     * // =&gt; 'slate'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span>(<span class="hljs-params">object, key, defaultValue</span>) </span>{
      <span class="hljs-keyword">var</span> value = object == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : object[key];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> defaultValue;
      }
      <span class="hljs-keyword">return</span> isFunction(value) ? object[key]() : value;
    }

    <span class="hljs-comment">/**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // =&gt; [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // =&gt; calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // =&gt; also calls `mage.castSpell(n)` three times
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">times</span>(<span class="hljs-params">n, callback, thisArg</span>) </span>{
      n = (n = +n) &gt; -<span class="hljs-number">1</span> ? n : <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>,
          result = <span class="hljs-built_in">Array</span>(n);

      callback = baseCreateCallback(callback, thisArg, <span class="hljs-number">1</span>);
      <span class="hljs-keyword">while</span> (++index &lt; n) {
        result[index] = callback(index);
      }
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">/**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // =&gt; 'contact_104'
     *
     * _.uniqueId();
     * // =&gt; '105'
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqueId</span>(<span class="hljs-params">prefix</span>) </span>{
      <span class="hljs-keyword">var</span> id = ++idCounter;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(prefix == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : prefix) + id;
    }

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>add functions that return wrapped values when chaining</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>add aliases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.callback = createCallback;
    lodash.collect = map;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>add functions to <code>lodash.prototype</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    mixin(assign({}, lodash));

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>add functions that return unwrapped values when chaining</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.endsWith = endsWith;
    lodash.escape = <span class="hljs-built_in">escape</span>;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = <span class="hljs-built_in">isFinite</span>;
    lodash.isFunction = isFunction;
    lodash.isNaN = <span class="hljs-built_in">isNaN</span>;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = <span class="hljs-built_in">parseInt</span>;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.snakeCase = snakeCase;
    lodash.startsWith = startsWith;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.truncate = truncate;
    lodash.unescape = <span class="hljs-built_in">unescape</span>;
    lodash.uniqueId = uniqueId;</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>add aliases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> source = {}
      baseForOwn(lodash, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, methodName</span>) </span>{
        <span class="hljs-keyword">if</span> (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      <span class="hljs-keyword">return</span> source;
    }(), <span class="hljs-literal">false</span>);

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>add functions capable of returning wrapped and unwrapped values when chaining</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;
    lodash.take = first;
    lodash.takeRight = last;
    lodash.takeRightWhile = last;
    lodash.takeWhile = first;</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>add aliases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.head = first;

    baseForOwn(lodash, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">func, methodName</span>) </span>{
      <span class="hljs-keyword">var</span> callbackable = methodName !== <span class="hljs-string">'sample'</span>;
      <span class="hljs-keyword">if</span> (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, guard</span>) </span>{
          <span class="hljs-keyword">var</span> chainAll = <span class="hljs-keyword">this</span>.__chain__,
              result = func(<span class="hljs-keyword">this</span>.__wrapped__, n, guard);

          <span class="hljs-keyword">return</span> !chainAll &amp;&amp; (n == <span class="hljs-literal">null</span> || (guard &amp;&amp; !(callbackable &amp;&amp; <span class="hljs-keyword">typeof</span> n == <span class="hljs-string">'function'</span>)))
            ? result
            : <span class="hljs-keyword">new</span> lodashWrapper(result, chainAll);
        };
      }
    });

    <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span>

    <span class="hljs-comment">/**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */</span>
    lodash.VERSION = version;</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>add “Chaining” functions to the wrapper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>add <code>Array</code> functions that return unwrapped values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    baseEach([<span class="hljs-string">'join'</span>, <span class="hljs-string">'pop'</span>, <span class="hljs-string">'shift'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName</span>) </span>{
      <span class="hljs-keyword">var</span> func = arrayRef[methodName];
      lodash.prototype[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> chainAll = <span class="hljs-keyword">this</span>.__chain__,
            result = func.apply(<span class="hljs-keyword">this</span>.__wrapped__, <span class="hljs-built_in">arguments</span>);

        <span class="hljs-keyword">return</span> chainAll
          ? <span class="hljs-keyword">new</span> lodashWrapper(result, chainAll)
          : result;
      };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>add <code>Array</code> functions that return the existing wrapped value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    baseEach([<span class="hljs-string">'push'</span>, <span class="hljs-string">'reverse'</span>, <span class="hljs-string">'sort'</span>, <span class="hljs-string">'unshift'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName</span>) </span>{
      <span class="hljs-keyword">var</span> func = arrayRef[methodName];
      lodash.prototype[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        func.apply(<span class="hljs-keyword">this</span>.__wrapped__, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>add <code>Array</code> functions that return new wrapped values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    baseEach([<span class="hljs-string">'concat'</span>, <span class="hljs-string">'splice'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName</span>) </span>{
      <span class="hljs-keyword">var</span> func = arrayRef[methodName];
      lodash.prototype[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> lodashWrapper(func.apply(<span class="hljs-keyword">this</span>.__wrapped__, <span class="hljs-built_in">arguments</span>), <span class="hljs-keyword">this</span>.__chain__);
      };
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>avoid array-like object bugs with <code>Array#shift</code> and <code>Array#splice</code>
in IE &lt; 9, Firefox &lt; 10, Narwhal, and RingoJS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!support.spliceObjects) {
      baseEach([<span class="hljs-string">'pop'</span>, <span class="hljs-string">'shift'</span>, <span class="hljs-string">'splice'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">methodName</span>) </span>{
        <span class="hljs-keyword">var</span> func = arrayRef[methodName],
            isSplice = methodName == <span class="hljs-string">'splice'</span>;

        lodash.prototype[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> chainAll = <span class="hljs-keyword">this</span>.__chain__,
              value = <span class="hljs-keyword">this</span>.__wrapped__,
              result = func.apply(value, <span class="hljs-built_in">arguments</span>);

          <span class="hljs-keyword">if</span> (value.length === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">delete</span> value[<span class="hljs-number">0</span>];
          }
          <span class="hljs-keyword">return</span> (chainAll || isSplice)
            ? <span class="hljs-keyword">new</span> lodashWrapper(result, chainAll)
            : result;
        };
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>add pseudo private property to be used and removed during the build process</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lodash._baseForIn = baseForIn;
    lodash._iteratorTemplate = iteratorTemplate;
    lodash._shimKeys = shimKeys;

    <span class="hljs-keyword">return</span> lodash;
  }

  <span class="hljs-comment">/*--------------------------------------------------------------------------*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>export Lo-Dash</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> _ = runInContext();</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>some AMD build optimizers like r.js check for condition patterns like the following:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define == <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> define.amd == <span class="hljs-string">'object'</span> &amp;&amp; define.amd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>Expose Lo-Dash to the global object even when an AMD loader is present in
case Lo-Dash is loaded with a RequireJS shim config.
See <a href="http://requirejs.org/docs/api.html#config-shim">http://requirejs.org/docs/api.html#config-shim</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    root._ = _;</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>define as an anonymous module so, through path mapping, it can be
referenced as the “underscore” module</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _;
    });
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>check for <code>exports</code> after <code>define</code> in case a build optimizer adds an <code>exports</code> object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (freeExports &amp;&amp; freeModule) {</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>in Node.js or RingoJS</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (moduleExports) {
      (freeModule.exports = _)._ = _;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>in Narwhal or Rhino -require</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">else</span> {
      freeExports._ = _;
    }
  }
  <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>in a browser or Rhino</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    root._ = _;
  }
}.call(<span class="hljs-keyword">this</span>));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
